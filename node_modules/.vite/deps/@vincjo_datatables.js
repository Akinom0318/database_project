import "./chunk-6F6SIVCY.js";
import {
  derived,
  writable
} from "./chunk-NNBC6TRB.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  component_subscribe,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  get_svelte_dataset,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-YSQZRWWN.js";
import "./chunk-REVP7M6M.js";
import {
  __publicField
} from "./chunk-TYRVL62N.js";

// node_modules/@vincjo/datatables/dist/local/utils.js
var isNull = (value) => {
  if (value === null || value === void 0 || value === "")
    return true;
  return false;
};
var isNotNull = (value) => {
  return !isNull(value);
};
var parseField = (field, uid) => {
  const identifier = uid ?? field.toString();
  if (typeof field === "string") {
    return {
      callback: (row) => row[field],
      identifier,
      key: field
    };
  } else if (typeof field === "function") {
    return {
      callback: field,
      identifier,
      key: void 0
    };
  }
  throw new Error(`Invalid field argument: ${String(field)}`);
};

// node_modules/@vincjo/datatables/dist/local/Comparator.js
var check = {
  isLike: (entry, value) => {
    return stringify(entry).indexOf(stringify(value)) > -1;
  },
  isNotLike: (entry, value) => {
    return stringify(entry).indexOf(stringify(value)) === -1;
  },
  startsWith: (entry, value) => {
    return stringify(entry).startsWith(stringify(value));
  },
  endsWith: (entry, value) => {
    return stringify(entry).endsWith(stringify(value));
  },
  isEqualTo: (entry, value) => {
    return stringify(entry) === stringify(value);
  },
  isNotEqualTo: (entry, value) => {
    return stringify(entry) !== stringify(value);
  },
  isGreaterThan: (entry, value) => {
    if (isNull2(entry))
      return false;
    return entry > value;
  },
  isGreaterThanOrEqualTo: (entry, value) => {
    if (isNull2(entry))
      return false;
    return entry >= value;
  },
  isLessThan: (entry, value) => {
    if (isNull2(entry))
      return false;
    return entry < value;
  },
  isLessThanOrEqualTo: (entry, value) => {
    if (isNull2(entry))
      return false;
    return entry <= value;
  },
  isBetween: (entry, value) => {
    if (isNull2(entry))
      return false;
    const [min, max] = value;
    return entry >= min && entry <= max;
  },
  isStrictlyBetween: (entry, value) => {
    if (isNull2(entry))
      return false;
    const [min, max] = value;
    return entry > min && entry < max;
  },
  isTrue: (entry, _) => {
    return entry === true;
  },
  isFalse: (entry, _) => {
    return entry === false;
  },
  isNull: (entry, _) => {
    return entry === null || entry === void 0;
  },
  isNotNull: (entry, _) => {
    return entry === null || entry === void 0 ? false : true;
  },
  whereIn: (entry, values = []) => {
    if (isNull2(entry))
      return false;
    if (values.length === 0)
      return false;
    for (const { value, comparator } of values) {
      if (comparator(entry, value)) {
        return true;
      }
    }
    return false;
  },
  /**
   * @deprecated use "isLike" instead
   * @since 1.12.7 2023-09-27
   */
  contains: (entry, value) => {
    return check.isLike(entry, value);
  }
};
function stringify(value = null) {
  return String(value).toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function isNull2(entry) {
  if (entry === null || entry === void 0)
    return true;
}

// node_modules/@vincjo/datatables/dist/local/handlers/EventHandler.js
var EventHandler = class {
  constructor() {
    __publicField(this, "events", {
      change: [],
      clearFilters: [],
      clearSearch: []
    });
    __publicField(this, "triggerChange", writable(0));
  }
  // legacy
  add(event, callback) {
    this.events[event].push(callback);
  }
  trigger(event) {
    for (const callback of this.events[event]) {
      callback();
    }
    if (event === "change") {
      this.triggerChange.update((store) => {
        return store + 1;
      });
    }
  }
};

// node_modules/@vincjo/datatables/dist/local/Context.js
var Context = class {
  constructor(data, params) {
    __publicField(this, "event");
    __publicField(this, "rowsPerPage");
    __publicField(this, "pageNumber");
    __publicField(this, "search");
    __publicField(this, "filters");
    __publicField(this, "filterCount");
    __publicField(this, "rawRows");
    __publicField(this, "filteredRows");
    __publicField(this, "pagedRows");
    __publicField(this, "rowCount");
    __publicField(this, "pages");
    __publicField(this, "pagesWithEllipsis");
    __publicField(this, "pageCount");
    __publicField(this, "sort");
    __publicField(this, "selected");
    __publicField(this, "selectScope");
    __publicField(this, "isAllSelected");
    this.event = new EventHandler();
    this.rowsPerPage = writable(params.rowsPerPage);
    this.pageNumber = writable(1);
    this.search = writable({});
    this.filters = writable([]);
    this.filterCount = this.createFilterCount();
    this.rawRows = writable(data);
    this.filteredRows = this.createFilteredRows();
    this.pagedRows = this.createPagedRows();
    this.rowCount = this.createRowCount();
    this.pages = this.createPages();
    this.pagesWithEllipsis = this.createPagesWithEllipsis();
    this.pageCount = this.createPageCount();
    this.sort = writable({});
    this.selected = writable([]);
    this.selectScope = writable("all");
    this.isAllSelected = this.createIsAllSelected();
  }
  createFilterCount() {
    return derived(this.filters, ($filters) => $filters.length);
  }
  createFilteredRows() {
    return derived([this.rawRows, this.search, this.filters], ([$rawRows, $search, $filters]) => {
      if ($search.value) {
        $rawRows = $rawRows.filter((row) => {
          const fields = $search.scope ?? Object.keys(row);
          const scope = fields.map((field) => {
            const { callback } = parseField(field);
            return callback;
          });
          return scope.some((callback) => {
            return this.match(callback(row), $search.value);
          });
        });
        this.pageNumber.set(1);
        this.selected.set([]);
        this.event.trigger("change");
      }
      if ($filters.length > 0) {
        $filters.forEach((filter) => {
          return $rawRows = $rawRows.filter((row) => {
            const entry = filter.callback(row);
            return this.match(entry, filter.value, filter.comparator);
          });
        });
        this.pageNumber.set(1);
        this.selected.set([]);
        this.event.trigger("change");
      }
      return $rawRows;
    });
  }
  match(entry, value, compare = null) {
    if (isNull(value)) {
      return true;
    }
    if (!entry && compare) {
      return compare(entry, value);
    }
    if (!entry)
      return check.isLike(entry, value);
    else if (typeof entry === "object") {
      return Object.keys(entry).some((k) => {
        return this.match(entry[k], value, compare);
      });
    }
    if (!compare)
      return check.isLike(entry, value);
    return compare(entry, value);
  }
  createPagedRows() {
    return derived([this.filteredRows, this.rowsPerPage, this.pageNumber], ([$filteredRows, $rowsPerPage, $pageNumber]) => {
      if (!$rowsPerPage) {
        return $filteredRows;
      }
      return $filteredRows.slice(($pageNumber - 1) * $rowsPerPage, $pageNumber * $rowsPerPage);
    });
  }
  createRowCount() {
    return derived([this.filteredRows, this.pageNumber, this.rowsPerPage], ([$filteredRows, $pageNumber, $rowsPerPage]) => {
      const total = $filteredRows.length;
      if (!$rowsPerPage) {
        return { total, start: 1, end: total };
      }
      return {
        total,
        start: $pageNumber * $rowsPerPage - $rowsPerPage + 1,
        end: Math.min($pageNumber * $rowsPerPage, $filteredRows.length)
      };
    });
  }
  createPages() {
    return derived([this.rowsPerPage, this.filteredRows], ([$rowsPerPage, $filteredRows]) => {
      if (!$rowsPerPage) {
        return [1];
      }
      const pages = Array.from(Array(Math.ceil($filteredRows.length / $rowsPerPage)));
      return pages.map((_, i) => i + 1);
    });
  }
  createPagesWithEllipsis() {
    return derived([this.pages, this.pageNumber], ([$pages, $pageNumber]) => {
      if ($pages.length <= 7) {
        return $pages;
      }
      const ellipse = null;
      const firstPage = 1;
      const lastPage = $pages.length;
      if ($pageNumber <= 4) {
        return [
          ...$pages.slice(0, 5),
          ellipse,
          lastPage
        ];
      } else if ($pageNumber < $pages.length - 3) {
        return [
          firstPage,
          ellipse,
          ...$pages.slice($pageNumber - 2, $pageNumber + 1),
          ellipse,
          lastPage
        ];
      } else {
        return [
          firstPage,
          ellipse,
          ...$pages.slice($pages.length - 5, $pages.length)
        ];
      }
    });
  }
  createPageCount() {
    return derived(this.pages, ($pages) => {
      return $pages.length;
    });
  }
  createIsAllSelected() {
    return derived([this.selected, this.pagedRows, this.filteredRows, this.selectScope], ([$selected, $pagedRows, $filteredRows, $selectScope]) => {
      const rowCount = $selectScope === "currentPage" ? $pagedRows.length : $filteredRows.length;
      if (rowCount === $selected.length && rowCount !== 0) {
        return true;
      }
      return false;
    });
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/SortHandler.js
var SortHandler = class {
  constructor(context) {
    __publicField(this, "rawRows");
    __publicField(this, "event");
    __publicField(this, "sort");
    __publicField(this, "backup");
    this.rawRows = context.rawRows;
    this.event = context.event;
    this.sort = context.sort;
    this.backup = [];
  }
  set(orderBy = null, uid) {
    if (!orderBy)
      return;
    const sort = get_store_value(this.sort);
    const { identifier } = parseField(orderBy, uid);
    if (sort.identifier !== identifier) {
      this.sort.update((store) => store.direction = null);
    }
    if (sort.direction === null || sort.direction === "desc") {
      this.asc(orderBy, uid);
    } else if (sort.direction === "asc") {
      this.desc(orderBy, uid);
    }
  }
  asc(orderBy, uid) {
    if (!orderBy)
      return;
    const { identifier, callback, key } = parseField(orderBy, uid);
    this.sort.set({ identifier, callback, direction: "asc", key });
    this.rawRows.update((store) => {
      store.sort((x, y) => {
        const [a, b] = [callback(x), callback(y)];
        if (a === b)
          return 0;
        if (a === null)
          return 1;
        if (b === null)
          return -1;
        if (typeof a === "boolean")
          return a === false ? 1 : -1;
        if (typeof a === "string")
          return a.localeCompare(b);
        if (typeof a === "number")
          return a - b;
        if (typeof a === "object")
          return JSON.stringify(a).localeCompare(JSON.stringify(b));
        else
          return String(a).localeCompare(String(b));
      });
      return store;
    });
    this.log({ identifier, callback, direction: "asc" });
    this.event.trigger("change");
  }
  desc(orderBy, uid) {
    if (!orderBy)
      return;
    const { identifier, callback, key } = parseField(orderBy, uid);
    this.sort.set({ identifier, callback, direction: "desc", key });
    this.rawRows.update((store) => {
      store.sort((x, y) => {
        const [a, b] = [callback(x), callback(y)];
        if (a === b)
          return 0;
        if (a === null)
          return 1;
        if (b === null)
          return -1;
        if (typeof b === "boolean")
          return b === false ? 1 : -1;
        if (typeof b === "string")
          return b.localeCompare(a);
        if (typeof b === "number")
          return b - a;
        if (typeof b === "object")
          return JSON.stringify(b).localeCompare(JSON.stringify(a));
        else
          return String(b).localeCompare(String(a));
      });
      return store;
    });
    this.log({ identifier, callback, direction: "desc" });
    this.event.trigger("change");
  }
  apply(params = null) {
    if (params) {
      switch (params.direction) {
        case "asc":
          return this.asc(params.orderBy);
        case "desc":
          return this.desc(params.orderBy);
        default:
          return this.set(params.orderBy);
      }
    } else {
      this.restore();
    }
  }
  clear() {
    this.backup = [];
    this.sort.set({});
  }
  define(orderBy, direction = "asc") {
    if (!orderBy)
      return;
    const { identifier, callback, key } = parseField(orderBy);
    this.sort.set({ identifier, callback, direction, key });
  }
  restore() {
    for (const sort of this.backup) {
      const { key, callback, direction } = sort;
      const param = key ?? callback;
      this[direction](param);
    }
  }
  log(sort) {
    this.backup = this.backup.filter((item) => item.identifier !== sort.identifier);
    if (this.backup.length >= 3) {
      const [_, slot2, slot3] = this.backup;
      this.backup = [slot2, slot3, sort];
    } else {
      this.backup = [...this.backup, sort];
    }
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/SelectHandler.js
var SelectHandler = class {
  constructor(context) {
    __publicField(this, "filteredRows");
    __publicField(this, "pagedRows");
    __publicField(this, "selected");
    __publicField(this, "scope");
    __publicField(this, "isAllSelected");
    __publicField(this, "event");
    this.filteredRows = context.filteredRows;
    this.pagedRows = context.pagedRows;
    this.selected = context.selected;
    this.scope = context.selectScope;
    this.isAllSelected = context.isAllSelected;
    this.event = context.event;
  }
  set(value) {
    const selected = get_store_value(this.selected);
    if (selected.includes(value)) {
      this.selected.set(selected.filter((item) => item !== value));
    } else {
      this.selected.set([value, ...selected]);
    }
  }
  all(selectBy = null) {
    const isAllSelected = get_store_value(this.isAllSelected);
    if (isAllSelected) {
      return this.clear();
    }
    const scope = get_store_value(this.scope);
    const rows = scope === "currentPage" ? get_store_value(this.pagedRows) : get_store_value(this.filteredRows);
    if (scope === "currentPage") {
      this.event.add("change", () => this.clear());
    }
    if (selectBy) {
      this.selected.set(rows.map((row) => row[selectBy]));
    } else {
      this.selected.set(rows);
    }
  }
  clear() {
    this.selected.set([]);
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/PageHandler.js
var PageHandler = class {
  constructor(context) {
    __publicField(this, "pageNumber");
    __publicField(this, "rowCount");
    __publicField(this, "rowsPerPage");
    __publicField(this, "event");
    this.pageNumber = context.pageNumber;
    this.rowCount = context.rowCount;
    this.rowsPerPage = context.rowsPerPage;
    this.event = context.event;
  }
  goto(number) {
    this.pageNumber.update((store) => {
      const rowsPerPage = get_store_value(this.rowsPerPage);
      if (rowsPerPage) {
        const total = get_store_value(this.rowCount).total;
        if (number >= 1 && number <= Math.ceil(total / rowsPerPage)) {
          store = number;
          this.event.trigger("change");
        }
      }
      return store;
    });
  }
  previous() {
    const number = get_store_value(this.pageNumber) - 1;
    this.goto(number);
  }
  next() {
    const number = get_store_value(this.pageNumber) + 1;
    this.goto(number);
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/SearchHandler.js
var SearchHandler = class {
  constructor(context) {
    __publicField(this, "search");
    __publicField(this, "event");
    this.search = context.search;
    this.event = context.event;
  }
  set(value, scope = null) {
    this.search.update((store) => {
      store = {
        value: value ?? "",
        scope: scope ?? null
      };
      return store;
    });
  }
  clear() {
    this.search.set({ value: null, scope: null });
    this.event.trigger("change");
    this.event.trigger("clearSearch");
  }
};

// node_modules/@vincjo/datatables/dist/local/handlers/FilterHandler.js
var FilterHandler = class {
  constructor(context) {
    __publicField(this, "filters");
    __publicField(this, "event");
    __publicField(this, "collection");
    this.filters = context.filters;
    this.event = context.event;
  }
  set(value, filterBy, comparator = null, name) {
    const { callback, identifier, key } = parseField(filterBy, name);
    const filter = { value, identifier, callback, comparator, key };
    this.filters.update((store) => {
      store = store.filter((item) => item.identifier !== identifier);
      if (isNotNull(value)) {
        store.push(filter);
      }
      return store;
    });
  }
  clear() {
    this.filters.set([]);
    this.event.trigger("change");
    this.event.trigger("clearFilters");
  }
  get() {
    if (this.collection) {
      return this.collection;
    }
    this.collection = this.createCollection();
    return this.collection;
  }
  createCollection() {
    return derived(this.filters, ($filters) => {
      return $filters.map(({ value, callback, key, comparator }) => {
        const filterBy = key ?? callback;
        return {
          value,
          filterBy,
          check: comparator ? comparator.name : "isLike"
          // set: (value: Value, comparator: Comparator<Row> = check.isLike) => {
          //     this.set(value, filterBy, comparator)
          // },
          // clear: () => {
          //     this.set(undefined, filterBy)
          // }
        };
      });
    });
  }
};

// node_modules/@vincjo/datatables/dist/local/helpers/FilterHelper.js
var FilterHelper = class {
  constructor(filterHandler, filterBy, comparator) {
    __publicField(this, "filterHandler");
    __publicField(this, "filterBy");
    __publicField(this, "uid");
    __publicField(this, "comparator");
    __publicField(this, "callback");
    this.filterHandler = filterHandler;
    this.filterBy = filterBy;
    this.uid = "f_" + Math.random().toString(28).substring(2);
    this.comparator = comparator ?? check.isLike;
    this.callback = () => null;
  }
  set(value, comparator) {
    if (comparator) {
      this.comparator = comparator;
    }
    this.filterHandler.set(value, this.filterBy, this.comparator, this.uid);
  }
  clear() {
    this.callback();
    this.filterHandler.set(void 0, this.filterBy);
  }
  on(event, callback) {
    this.callback = callback;
  }
};

// node_modules/@vincjo/datatables/dist/local/helpers/AdvancedFilterHelper.js
var AdvancedFilterHandler = class {
  constructor(filterHandler, filterBy) {
    __publicField(this, "filterHandler");
    __publicField(this, "criteria");
    __publicField(this, "filterBy");
    __publicField(this, "selected");
    this.filterHandler = filterHandler;
    this.filterBy = filterBy;
    this.criteria = [];
    this.selected = writable([]);
  }
  set(value, comparator = check.isLike) {
    if (this.criteria.find((criterion) => criterion.value === value)) {
      this.criteria = this.criteria.filter((criterion) => criterion.value !== value);
    } else {
      this.criteria = [{ value, comparator }, ...this.criteria];
    }
    if (this.criteria.length === 0) {
      return this.clear();
    }
    this.filterHandler.set(this.criteria, this.filterBy, check.whereIn);
    this.selected.set(this.criteria.map((criterion) => criterion.value));
  }
  getSelected() {
    return this.selected;
  }
  clear() {
    this.criteria = [];
    this.selected.set([]);
    this.filterHandler.set(void 0, this.filterBy, check.whereIn);
  }
};

// node_modules/@vincjo/datatables/dist/local/helpers/CalculationHelper.js
var CalcultationHandler = class {
  constructor(context, field, param) {
    __publicField(this, "rawRows");
    __publicField(this, "filteredRows");
    __publicField(this, "callback");
    __publicField(this, "precision");
    this.rawRows = context.rawRows;
    this.filteredRows = context.filteredRows;
    this.callback = parseField(field).callback;
    this.precision = param.precision;
  }
  distinct(callback = null) {
    const rawRows = get_store_value(this.rawRows);
    const values = rawRows.map((row) => this.callback(row));
    const array = callback ? callback(values) : values;
    const result = array.reduce((acc, curr) => {
      acc[curr] = (acc[curr] ?? 0) + 1;
      return acc;
    }, {});
    return Object.entries(result).map(([value, count]) => ({ value, count }));
  }
  avg(callback = null) {
    return derived(this.filteredRows, ($filteredRows) => {
      if ($filteredRows.length === 0)
        return 0;
      const values = $filteredRows.map((row) => this.callback(row)).filter(Boolean);
      const array = callback ? callback(values) : values;
      return this.round(array.reduce((acc, curr) => acc + curr, 0) / array.length);
    });
  }
  sum(callback = null) {
    return derived(this.filteredRows, ($filteredRows) => {
      const values = $filteredRows.map((row) => this.callback(row));
      const array = callback ? callback(values) : values;
      return this.round(array.reduce((acc, curr) => acc + curr, 0));
    });
  }
  bounds(callback = null) {
    const rawRows = get_store_value(this.rawRows);
    const values = rawRows.map((row) => this.callback(row));
    const numbers = callback ? callback(values) : values;
    return [
      Math.min(...numbers.filter(Boolean)),
      Math.max(...numbers.filter(Boolean))
    ];
  }
  setPrecision(value) {
    this.precision = value;
  }
  round(value) {
    if (this.precision === 0) {
      return Math.round(value);
    }
    const denominator = Math.pow(10, this.precision);
    return Math.round((value + Number.EPSILON) * denominator) / denominator;
  }
};

// node_modules/@vincjo/datatables/dist/local/DataHandler.js
var DataHandler = class {
  constructor(data = [], params = { rowsPerPage: null }) {
    __publicField(this, "context");
    __publicField(this, "sortHandler");
    __publicField(this, "selectHandler");
    __publicField(this, "pageHandler");
    __publicField(this, "searchHandler");
    __publicField(this, "filterHandler");
    __publicField(this, "i18n");
    this.i18n = this.translate(params.i18n);
    this.context = new Context(data, params);
    this.sortHandler = new SortHandler(this.context);
    this.selectHandler = new SelectHandler(this.context);
    this.pageHandler = new PageHandler(this.context);
    this.searchHandler = new SearchHandler(this.context);
    this.filterHandler = new FilterHandler(this.context);
  }
  setRows(data) {
    this.context.rawRows.set(data);
    this.context.event.trigger("change");
    this.applySort();
  }
  getRows() {
    return this.context.pagedRows;
  }
  getAllRows() {
    return this.context.filteredRows;
  }
  getRowCount() {
    return this.context.rowCount;
  }
  getRowsPerPage() {
    return this.context.rowsPerPage;
  }
  getPages(param = { ellipsis: false }) {
    if (param.ellipsis) {
      return this.context.pagesWithEllipsis;
    }
    return this.context.pages;
  }
  getPageCount() {
    return this.context.pageCount;
  }
  getPageNumber() {
    return this.context.pageNumber;
  }
  setPage(value) {
    switch (value) {
      case "previous":
        return this.pageHandler.previous();
      case "next":
        return this.pageHandler.next();
      default:
        return this.pageHandler.goto(value);
    }
  }
  search(value, scope = null) {
    this.searchHandler.set(value, scope);
  }
  clearSearch() {
    this.searchHandler.clear();
  }
  sort(orderBy, identifier) {
    this.setPage(1);
    this.sortHandler.set(orderBy, identifier);
  }
  sortAsc(orderBy, identifier) {
    this.setPage(1);
    this.sortHandler.asc(orderBy, identifier);
  }
  sortDesc(orderBy, identifier) {
    this.setPage(1);
    this.sortHandler.desc(orderBy, identifier);
  }
  getSort() {
    return this.context.sort;
  }
  applySort(params = null) {
    this.sortHandler.apply(params);
  }
  defineSort(orderBy, direction) {
    this.sortHandler.define(orderBy, direction);
  }
  clearSort() {
    this.sortHandler.clear();
  }
  filter(value, filterBy, comparator = null) {
    this.filterHandler.set(value, filterBy, comparator);
  }
  getFilters() {
    return this.filterHandler.get();
  }
  createFilter(filterBy, comparator) {
    return new FilterHelper(this.filterHandler, filterBy, comparator);
  }
  createAdvancedFilter(filterBy) {
    return new AdvancedFilterHandler(this.filterHandler, filterBy);
  }
  getFilterCount() {
    return this.context.filterCount;
  }
  clearFilters() {
    this.filterHandler.clear();
  }
  select(value) {
    this.selectHandler.set(value);
  }
  getSelected() {
    return this.context.selected;
  }
  selectAll(params = {}) {
    this.context.selectScope.set(params.scope === "currentPage" ? "currentPage" : "all");
    this.selectHandler.all(params.selectBy ?? null);
  }
  isAllSelected() {
    return this.context.isAllSelected;
  }
  on(event, callback) {
    this.context.event.add(event, callback);
  }
  createCalculation(field, param = null) {
    return new CalcultationHandler(this.context, field, { precision: (param == null ? void 0 : param.precision) ?? 2 });
  }
  translate(i18n) {
    return {
      ...{
        search: "Search...",
        show: "Show",
        entries: "entries",
        filter: "Filter",
        rowCount: "Showing {start} to {end} of {total} entries",
        noRows: "No entries found",
        previous: "Previous",
        next: "Next"
      },
      ...i18n
    };
  }
  /**
   * @deprecated use setRows() instead
   * @since v0.9.99 2023-01-16
   */
  update(data) {
    console.log("%c%s", "color:#e65100;background:#fff3e0;font-size:12px;border-radius:4px;padding:4px;text-align:center;", `DataHandler.update(data) method is deprecated. Please use DataHandler.setRows(data) instead`);
    this.context.rawRows.set(data);
  }
  /**
   * @deprecated use applySort() instead
   * @since v1.11.0 2023-07-11
   */
  applySorting(params = null) {
    this.applySort(params);
  }
  /**
   * @deprecated use getSort() instead
   * @since v1.11.0 2023-07-11
   */
  getSorted() {
    return this.getSort();
  }
  getTriggerChange() {
    return this.context.event.triggerChange;
  }
};

// node_modules/@vincjo/datatables/dist/local/Th.svelte
var file = "node_modules\\@vincjo\\datatables\\dist\\local\\Th.svelte";
function add_css(target) {
  append_styles(target, "svelte-cur88x", "th.svelte-cur88x.svelte-cur88x{background:inherit;padding:8px 20px;white-space:nowrap;font-size:13px;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-bottom:1px solid #e0e0e0}th.sortable.svelte-cur88x.svelte-cur88x{cursor:pointer}th.svelte-cur88x strong.svelte-cur88x{white-space:pre-wrap;font-size:13.5px;line-height:16px}th.sortable.svelte-cur88x div.flex.svelte-cur88x{padding:0;display:flex;align-items:center;height:100%}th.sortable.svelte-cur88x span.svelte-cur88x{padding-left:8px}th.sortable.svelte-cur88x span.svelte-cur88x:before,th.sortable.svelte-cur88x span.svelte-cur88x:after{border:4px solid transparent;content:'';display:block;height:0;width:0}th.sortable.svelte-cur88x span.svelte-cur88x:before{border-bottom-color:#e0e0e0;margin-top:2px}th.sortable.svelte-cur88x span.svelte-cur88x:after{border-top-color:#e0e0e0;margin-top:2px}th.active.sortable.svelte-cur88x span.asc.svelte-cur88x:before{border-bottom-color:#9e9e9e}th.active.sortable.svelte-cur88x span.desc.svelte-cur88x:after{border-top-color:#9e9e9e}th.svelte-cur88x:not(.sortable) span.svelte-cur88x{visibility:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGguc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRGVza3RvcFxcZGF0YWJhc2VfcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxAdmluY2pvXFxkYXRhdGFibGVzXFxkaXN0XFxsb2NhbFxcVGguc3ZlbHRlIl19 */");
}
function create_fragment(ctx) {
  let th;
  let div;
  let strong;
  let t;
  let span;
  let th_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      th = element("th");
      div = element("div");
      strong = element("strong");
      if (default_slot)
        default_slot.c();
      t = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, rowspan: true });
      var th_nodes = children(th);
      div = claim_element(th_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      strong = claim_element(div_nodes, "STRONG", { class: true });
      var strong_nodes = children(strong);
      if (default_slot)
        default_slot.l(strong_nodes);
      strong_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(strong, "class", "svelte-cur88x");
      add_location(strong, file, 19, 8, 553);
      add_location(strong, file, 19, 8, 553);
      attr_dev(span, "class", "svelte-cur88x");
      toggle_class(
        span,
        "asc",
        /*$sort*/
        ctx[5].direction === "asc"
      );
      toggle_class(
        span,
        "desc",
        /*$sort*/
        ctx[5].direction === "desc"
      );
      add_location(span, file, 22, 8, 612);
      add_location(span, file, 22, 8, 612);
      attr_dev(div, "class", "flex svelte-cur88x");
      set_style(
        div,
        "justify-content",
        /*align*/
        ctx[3] === "left" ? "flex-start" : (
          /*align*/
          ctx[3] === "right" ? "flex-end" : "center"
        )
      );
      add_location(div, file, 15, 4, 401);
      add_location(div, file, 15, 4, 401);
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*$$props*/
        ctx[7].class ?? ""
      ) + " svelte-cur88x");
      attr_dev(
        th,
        "rowspan",
        /*rowSpan*/
        ctx[4]
      );
      toggle_class(
        th,
        "sortable",
        /*orderBy*/
        ctx[1]
      );
      toggle_class(
        th,
        "active",
        /*$sort*/
        ctx[5].identifier === /*identifier*/
        ctx[2]
      );
      add_location(th, file, 8, 0, 195);
      add_location(th, file, 8, 0, 195);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, div);
      append_hydration_dev(div, strong);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      append_hydration_dev(div, t);
      append_hydration_dev(div, span);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          th,
          "click",
          /*click_handler*/
          ctx[10],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$sort*/
      32) {
        toggle_class(
          span,
          "asc",
          /*$sort*/
          ctx2[5].direction === "asc"
        );
      }
      if (!current || dirty & /*$sort*/
      32) {
        toggle_class(
          span,
          "desc",
          /*$sort*/
          ctx2[5].direction === "desc"
        );
      }
      if (dirty & /*align*/
      8) {
        set_style(
          div,
          "justify-content",
          /*align*/
          ctx2[3] === "left" ? "flex-start" : (
            /*align*/
            ctx2[3] === "right" ? "flex-end" : "center"
          )
        );
      }
      if (!current || dirty & /*$$props*/
      128 && th_class_value !== (th_class_value = null_to_empty(
        /*$$props*/
        ctx2[7].class ?? ""
      ) + " svelte-cur88x")) {
        attr_dev(th, "class", th_class_value);
      }
      if (!current || dirty & /*rowSpan*/
      16) {
        attr_dev(
          th,
          "rowspan",
          /*rowSpan*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$$props, orderBy*/
      130) {
        toggle_class(
          th,
          "sortable",
          /*orderBy*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$$props, $sort, identifier*/
      164) {
        toggle_class(
          th,
          "active",
          /*$sort*/
          ctx2[5].identifier === /*identifier*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $sort;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Th", slots, ["default"]);
  let { handler } = $$props;
  let { orderBy } = $$props;
  let { identifier = orderBy == null ? void 0 : orderBy.toString() } = $$props;
  let { align = "left" } = $$props;
  let { rowSpan = 1 } = $$props;
  const sort = handler.getSort();
  validate_store(sort, "sort");
  component_subscribe($$self, sort, (value) => $$invalidate(5, $sort = value));
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<Th> was created without expected prop 'handler'");
    }
    if (orderBy === void 0 && !("orderBy" in $$props || $$self.$$.bound[$$self.$$.props["orderBy"]])) {
      console.warn("<Th> was created without expected prop 'orderBy'");
    }
  });
  const click_handler = () => handler.sort(orderBy, identifier);
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("orderBy" in $$new_props)
      $$invalidate(1, orderBy = $$new_props.orderBy);
    if ("identifier" in $$new_props)
      $$invalidate(2, identifier = $$new_props.identifier);
    if ("align" in $$new_props)
      $$invalidate(3, align = $$new_props.align);
    if ("rowSpan" in $$new_props)
      $$invalidate(4, rowSpan = $$new_props.rowSpan);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    handler,
    orderBy,
    identifier,
    align,
    rowSpan,
    sort,
    $sort
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("orderBy" in $$props)
      $$invalidate(1, orderBy = $$new_props.orderBy);
    if ("identifier" in $$props)
      $$invalidate(2, identifier = $$new_props.identifier);
    if ("align" in $$props)
      $$invalidate(3, align = $$new_props.align);
    if ("rowSpan" in $$props)
      $$invalidate(4, rowSpan = $$new_props.rowSpan);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    handler,
    orderBy,
    identifier,
    align,
    rowSpan,
    $sort,
    sort,
    $$props,
    $$scope,
    slots,
    click_handler
  ];
}
var Th = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        handler: 0,
        orderBy: 1,
        identifier: 2,
        align: 3,
        rowSpan: 4
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Th",
      options,
      id: create_fragment.name
    });
  }
  get handler() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orderBy() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orderBy(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get identifier() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set identifier(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowSpan() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowSpan(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Th_default = Th;

// node_modules/@vincjo/datatables/dist/local/ThFilter.svelte
var file2 = "node_modules\\@vincjo\\datatables\\dist\\local\\ThFilter.svelte";
function add_css2(target) {
  append_styles(target, "svelte-7cnbqf", "th.svelte-7cnbqf{border-bottom:1px solid #e0e0e0}input.svelte-7cnbqf{width:100%;height:24px;border:none;text-align:left;padding:0 20px;background:inherit;outline:none;border-radius:0;font-size:14px;font-family:Arial, Helvetica, sans-serif}input.svelte-7cnbqf::-moz-placeholder{color:#bdbdbd;font-style:italic;font-size:13px}input.svelte-7cnbqf::placeholder{color:#bdbdbd;font-style:italic;font-size:13px}input.svelte-7cnbqf:focus{outline:none;border:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGhGaWx0ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRGVza3RvcFxcZGF0YWJhc2VfcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxAdmluY2pvXFxkYXRhdGFibGVzXFxkaXN0XFxsb2NhbFxcVGhGaWx0ZXIuc3ZlbHRlIl19 */");
}
function create_fragment2(ctx) {
  let th;
  let input;
  let input_placeholder_value;
  let th_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      th = element("th");
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      input = claim_element(th_nodes, "INPUT", {
        type: true,
        placeholder: true,
        spellcheck: true,
        class: true
      });
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      attr_dev(input, "placeholder", input_placeholder_value = /*handler*/
      ctx[0].i18n.filter);
      attr_dev(input, "spellcheck", "false");
      attr_dev(input, "class", "svelte-7cnbqf");
      set_style(
        input,
        "text-align",
        /*align*/
        ctx[2]
      );
      add_location(input, file2, 9, 4, 225);
      add_location(input, file2, 9, 4, 225);
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*$$props*/
        ctx[5].class ?? ""
      ) + " svelte-7cnbqf");
      add_location(th, file2, 8, 0, 187);
      add_location(th, file2, 8, 0, 187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, input);
      set_input_value(
        input,
        /*value*/
        ctx[4]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*handler*/
      1 && input_placeholder_value !== (input_placeholder_value = /*handler*/
      ctx2[0].i18n.filter)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*value*/
      16 && input.value !== /*value*/
      ctx2[4]) {
        set_input_value(
          input,
          /*value*/
          ctx2[4]
        );
      }
      if (dirty & /*align*/
      4) {
        set_style(
          input,
          "text-align",
          /*align*/
          ctx2[2]
        );
      }
      if (dirty & /*$$props*/
      32 && th_class_value !== (th_class_value = null_to_empty(
        /*$$props*/
        ctx2[5].class ?? ""
      ) + " svelte-7cnbqf")) {
        attr_dev(th, "class", th_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ThFilter", slots, []);
  let { handler } = $$props;
  let { filterBy } = $$props;
  let { align = "left" } = $$props;
  let { comparator = null } = $$props;
  let value = "";
  handler.on("clearFilters", () => $$invalidate(4, value = ""));
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<ThFilter> was created without expected prop 'handler'");
    }
    if (filterBy === void 0 && !("filterBy" in $$props || $$self.$$.bound[$$self.$$.props["filterBy"]])) {
      console.warn("<ThFilter> was created without expected prop 'filterBy'");
    }
  });
  function input_input_handler() {
    value = this.value;
    $$invalidate(4, value);
  }
  const input_handler = () => handler.filter(value, filterBy, comparator);
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("filterBy" in $$new_props)
      $$invalidate(1, filterBy = $$new_props.filterBy);
    if ("align" in $$new_props)
      $$invalidate(2, align = $$new_props.align);
    if ("comparator" in $$new_props)
      $$invalidate(3, comparator = $$new_props.comparator);
  };
  $$self.$capture_state = () => ({
    handler,
    filterBy,
    align,
    comparator,
    value
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("filterBy" in $$props)
      $$invalidate(1, filterBy = $$new_props.filterBy);
    if ("align" in $$props)
      $$invalidate(2, align = $$new_props.align);
    if ("comparator" in $$props)
      $$invalidate(3, comparator = $$new_props.comparator);
    if ("value" in $$props)
      $$invalidate(4, value = $$new_props.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    handler,
    filterBy,
    align,
    comparator,
    value,
    $$props,
    input_input_handler,
    input_handler
  ];
}
var ThFilter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        handler: 0,
        filterBy: 1,
        align: 2,
        comparator: 3
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThFilter",
      options,
      id: create_fragment2.name
    });
  }
  get handler() {
    throw new Error("<ThFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<ThFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterBy() {
    throw new Error("<ThFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterBy(value) {
    throw new Error("<ThFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<ThFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<ThFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get comparator() {
    throw new Error("<ThFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set comparator(value) {
    throw new Error("<ThFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ThFilter_default = ThFilter;

// node_modules/@vincjo/datatables/dist/local/Pagination.svelte
var file3 = "node_modules\\@vincjo\\datatables\\dist\\local\\Pagination.svelte";
function add_css3(target) {
  append_styles(target, "svelte-tshs7f", "section.svelte-tshs7f{display:flex}button.svelte-tshs7f{background:inherit;height:32px;width:32px;color:#616161;cursor:pointer;font-size:13px;margin:0;padding:0;transition:all, 0.2s;line-height:32px;border:1px solid #e0e0e0;border-right:none;border-radius:0;outline:none}button.svelte-tshs7f:first-child{border-radius:4px 0 0 4px}button.svelte-tshs7f:last-child{border-right:1px solid #e0e0e0;border-radius:0 4px 4px 0}button.svelte-tshs7f:first-child:not(.small),button.svelte-tshs7f:last-child:not(.small){min-width:72px}button.svelte-tshs7f:not(.active):hover{background:#eee}button.ellipse.svelte-tshs7f:hover{background:inherit;cursor:default}button.active.svelte-tshs7f{background:#eee;font-weight:bold;cursor:default}button.disabled.svelte-tshs7f:hover{background:inherit;cursor:default}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFnaW5hdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEZXNrdG9wXFxkYXRhYmFzZV9wcm9qZWN0XFxub2RlX21vZHVsZXNcXEB2aW5jam9cXGRhdGF0YWJsZXNcXGRpc3RcXGxvY2FsXFxQYWdpbmF0aW9uLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let button0;
  let html_tag;
  let raw0_value = (
    /*handler*/
    ctx[0].i18n.previous + ""
  );
  let t0;
  let t1;
  let button1;
  let html_tag_1;
  let raw1_value = (
    /*handler*/
    ctx[0].i18n.next + ""
  );
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*$pages*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      button0 = element("button");
      html_tag = new HtmlTagHydration(false);
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      button1 = element("button");
      html_tag_1 = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button0 = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      html_tag = claim_html_tag(button0_nodes, false);
      button0_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      html_tag_1 = claim_html_tag(button1_nodes, false);
      button1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", "svelte-tshs7f");
      toggle_class(
        button0,
        "disabled",
        /*$pageNumber*/
        ctx[2] === 1
      );
      add_location(button0, file3, 38, 8, 1116);
      add_location(button0, file3, 38, 8, 1116);
      html_tag_1.a = null;
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", "svelte-tshs7f");
      toggle_class(
        button1,
        "disabled",
        /*$pageNumber*/
        ctx[2] === /*$pageCount*/
        ctx[3]
      );
      add_location(button1, file3, 55, 8, 1667);
      add_location(button1, file3, 55, 8, 1667);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button0, anchor);
      html_tag.m(raw0_value, button0);
      insert_hydration_dev(target, t0, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button1, anchor);
      html_tag_1.m(raw1_value, button1);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler_4*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_6*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && raw0_value !== (raw0_value = /*handler*/
      ctx2[0].i18n.previous + ""))
        html_tag.p(raw0_value);
      if (dirty & /*$pageNumber*/
      4) {
        toggle_class(
          button0,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === 1
        );
      }
      if (dirty & /*$pageNumber, $pages, handler*/
      21) {
        each_value = ensure_array_like_dev(
          /*$pages*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(t1.parentNode, t1);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*handler*/
      1 && raw1_value !== (raw1_value = /*handler*/
      ctx2[0].i18n.next + ""))
        html_tag_1.p(raw1_value);
      if (dirty & /*$pageNumber, $pageCount*/
      12) {
        toggle_class(
          button1,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === /*$pageCount*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button0);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(button1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(38:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let button0;
  let textContent = "❬❬";
  let t1;
  let button1;
  let textContent_1 = "❮";
  let t3;
  let button2;
  let textContent_2 = "❯";
  let t5;
  let button3;
  let textContent_3 = "❭❭";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button0 = element("button");
      button0.textContent = textContent;
      t1 = space();
      button1 = element("button");
      button1.textContent = textContent_1;
      t3 = space();
      button2 = element("button");
      button2.textContent = textContent_2;
      t5 = space();
      button3 = element("button");
      button3.textContent = textContent_3;
      this.h();
    },
    l: function claim(nodes) {
      button0 = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-16n9ron")
        button0.textContent = textContent;
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button1) !== "svelte-1phz6f1")
        button1.textContent = textContent_1;
      t3 = claim_space(nodes);
      button2 = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button2) !== "svelte-d0zv7q")
        button2.textContent = textContent_2;
      t5 = claim_space(nodes);
      button3 = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button3) !== "svelte-1rg1h5c")
        button3.textContent = textContent_3;
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", "small svelte-tshs7f");
      toggle_class(
        button0,
        "disabled",
        /*$pageNumber*/
        ctx[2] === 1
      );
      add_location(button0, file3, 9, 8, 274);
      add_location(button0, file3, 9, 8, 274);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", "svelte-tshs7f");
      toggle_class(
        button1,
        "disabled",
        /*$pageNumber*/
        ctx[2] === 1
      );
      add_location(button1, file3, 17, 8, 502);
      add_location(button1, file3, 17, 8, 502);
      attr_dev(button2, "class", "svelte-tshs7f");
      toggle_class(
        button2,
        "disabled",
        /*$pageNumber*/
        ctx[2] === /*$pageCount*/
        ctx[3]
      );
      add_location(button2, file3, 24, 8, 704);
      add_location(button2, file3, 24, 8, 704);
      attr_dev(button3, "class", "small svelte-tshs7f");
      toggle_class(
        button3,
        "disabled",
        /*$pageNumber*/
        ctx[2] === /*$pageCount*/
        ctx[3]
      );
      add_location(button3, file3, 30, 8, 884);
      add_location(button3, file3, 30, 8, 884);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button1, anchor);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, button2, anchor);
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, button3, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            /*click_handler_2*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button3,
            "click",
            /*click_handler_3*/
            ctx[12],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$pageNumber*/
      4) {
        toggle_class(
          button0,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === 1
        );
      }
      if (dirty & /*$pageNumber*/
      4) {
        toggle_class(
          button1,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === 1
        );
      }
      if (dirty & /*$pageNumber, $pageCount*/
      12) {
        toggle_class(
          button2,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === /*$pageCount*/
          ctx2[3]
        );
      }
      if (dirty & /*$pageNumber, $pageCount*/
      12) {
        toggle_class(
          button3,
          "disabled",
          /*$pageNumber*/
          ctx2[2] === /*$pageCount*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button0);
        detach_dev(t1);
        detach_dev(button1);
        detach_dev(t3);
        detach_dev(button2);
        detach_dev(t5);
        detach_dev(button3);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(9:4) {#if small}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let button;
  let t_value = (
    /*page*/
    (ctx[16] ?? "...") + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[14](
        /*page*/
        ctx[16]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "svelte-tshs7f");
      toggle_class(
        button,
        "active",
        /*$pageNumber*/
        ctx[2] === /*page*/
        ctx[16]
      );
      toggle_class(
        button,
        "ellipse",
        /*page*/
        ctx[16] === null
      );
      add_location(button, file3, 46, 12, 1375);
      add_location(button, file3, 46, 12, 1375);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_5, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$pages*/
      16 && t_value !== (t_value = /*page*/
      (ctx[16] ?? "...") + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$pageNumber, $pages*/
      20) {
        toggle_class(
          button,
          "active",
          /*$pageNumber*/
          ctx[2] === /*page*/
          ctx[16]
        );
      }
      if (dirty & /*$pages*/
      16) {
        toggle_class(
          button,
          "ellipse",
          /*page*/
          ctx[16] === null
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(46:8) {#each $pages as page}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let section;
  let section_class_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*small*/
      ctx2[1]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      section = element("section");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if_block.l(section_nodes);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(section, "class", section_class_value = null_to_empty(
        /*$$props*/
        ctx[8].class ?? ""
      ) + " svelte-tshs7f");
      add_location(section, file3, 7, 0, 210);
      add_location(section, file3, 7, 0, 210);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      if_block.m(section, null);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(section, null);
        }
      }
      if (dirty & /*$$props*/
      256 && section_class_value !== (section_class_value = null_to_empty(
        /*$$props*/
        ctx2[8].class ?? ""
      ) + " svelte-tshs7f")) {
        attr_dev(section, "class", section_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $pageNumber;
  let $pageCount;
  let $pages;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, []);
  let { handler } = $$props;
  let { small = false } = $$props;
  const pageNumber = handler.getPageNumber();
  validate_store(pageNumber, "pageNumber");
  component_subscribe($$self, pageNumber, (value) => $$invalidate(2, $pageNumber = value));
  const pageCount = handler.getPageCount();
  validate_store(pageCount, "pageCount");
  component_subscribe($$self, pageCount, (value) => $$invalidate(3, $pageCount = value));
  const pages = handler.getPages({ ellipsis: true });
  validate_store(pages, "pages");
  component_subscribe($$self, pages, (value) => $$invalidate(4, $pages = value));
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<Pagination> was created without expected prop 'handler'");
    }
  });
  const click_handler = () => handler.setPage(1);
  const click_handler_1 = () => handler.setPage("previous");
  const click_handler_2 = () => handler.setPage("next");
  const click_handler_3 = () => handler.setPage($pageCount);
  const click_handler_4 = () => handler.setPage("previous");
  const click_handler_5 = (page) => handler.setPage(page);
  const click_handler_6 = () => handler.setPage("next");
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props)
      $$invalidate(1, small = $$new_props.small);
  };
  $$self.$capture_state = () => ({
    handler,
    small,
    pageNumber,
    pageCount,
    pages,
    $pageNumber,
    $pageCount,
    $pages
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$props)
      $$invalidate(1, small = $$new_props.small);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    handler,
    small,
    $pageNumber,
    $pageCount,
    $pages,
    pageNumber,
    pageCount,
    pages,
    $$props,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { handler: 0, small: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment3.name
    });
  }
  get handler() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;

// node_modules/@vincjo/datatables/dist/local/RowCount.svelte
var file4 = "node_modules\\@vincjo\\datatables\\dist\\local\\RowCount.svelte";
function add_css4(target) {
  append_styles(target, "svelte-9akqhk", "aside.svelte-9akqhk{color:#616161;line-height:32px;font-size:14px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm93Q291bnQuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRGVza3RvcFxcZGF0YWJhc2VfcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxAdmluY2pvXFxkYXRhdGFibGVzXFxkaXN0XFxsb2NhbFxcUm93Q291bnQuc3ZlbHRlIl19 */");
}
function create_else_block_1(ctx) {
  let t_value = (
    /*handler*/
    ctx[0].i18n.noRows + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.noRows + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(20:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let html_tag;
  let raw_value = (
    /*handler*/
    ctx[0].i18n.rowCount.replace("{start}", `<b>${/*$rowCount*/
    ctx[2].start}</b>`).replace("{end}", `<b>${/*$rowCount*/
    ctx[2].end}</b>`).replace("{total}", `<b>${/*$rowCount*/
    ctx[2].total}</b>`) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler, $rowCount*/
      5 && raw_value !== (raw_value = /*handler*/
      ctx2[0].i18n.rowCount.replace("{start}", `<b>${/*$rowCount*/
      ctx2[2].start}</b>`).replace("{end}", `<b>${/*$rowCount*/
      ctx2[2].end}</b>`).replace("{total}", `<b>${/*$rowCount*/
      ctx2[2].total}</b>`) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(15:34) ",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$rowCount*/
      ctx2[2].total > 0
    )
      return create_if_block_1;
    return create_else_block2;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(7:4) {#if small}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let t_value = (
    /*handler*/
    ctx[0].i18n.noRows + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.noRows + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(12:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let b0;
  let t0_value = (
    /*$rowCount*/
    ctx[2].start + ""
  );
  let t0;
  let t1;
  let b1;
  let t2_value = (
    /*$rowCount*/
    ctx[2].end + ""
  );
  let t2;
  let t3;
  let b2;
  let t4_value = (
    /*$rowCount*/
    ctx[2].total + ""
  );
  let t4;
  const block = {
    c: function create() {
      b0 = element("b");
      t0 = text(t0_value);
      t1 = text("-\r\n            ");
      t1 = text("-\r\n            ");
      b1 = element("b");
      t2 = text(t2_value);
      t3 = text("/\r\n            ");
      t3 = text("/\r\n            ");
      b2 = element("b");
      t4 = text(t4_value);
      this.h();
    },
    l: function claim(nodes) {
      b0 = claim_element(nodes, "B", {});
      var b0_nodes = children(b0);
      t0 = claim_text(b0_nodes, t0_value);
      b0_nodes.forEach(detach_dev);
      t1 = claim_text(nodes, "-\r\n            ");
      t1 = claim_text(nodes, "-\r\n            ");
      b1 = claim_element(nodes, "B", {});
      var b1_nodes = children(b1);
      t2 = claim_text(b1_nodes, t2_value);
      b1_nodes.forEach(detach_dev);
      t3 = claim_text(nodes, "/\r\n            ");
      t3 = claim_text(nodes, "/\r\n            ");
      b2 = claim_element(nodes, "B", {});
      var b2_nodes = children(b2);
      t4 = claim_text(b2_nodes, t4_value);
      b2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b0, file4, 8, 12, 211);
      add_location(b1, file4, 9, 12, 250);
      add_location(b2, file4, 10, 12, 287);
      add_location(b0, file4, 8, 12, 211);
      add_location(b1, file4, 9, 12, 250);
      add_location(b2, file4, 10, 12, 287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, b0, anchor);
      append_hydration_dev(b0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, b1, anchor);
      append_hydration_dev(b1, t2);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, b2, anchor);
      append_hydration_dev(b2, t4);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$rowCount*/
      4 && t0_value !== (t0_value = /*$rowCount*/
      ctx2[2].start + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*$rowCount*/
      4 && t2_value !== (t2_value = /*$rowCount*/
      ctx2[2].end + ""))
        set_data_dev(t2, t2_value);
      if (dirty & /*$rowCount*/
      4 && t4_value !== (t4_value = /*$rowCount*/
      ctx2[2].total + ""))
        set_data_dev(t4, t4_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(b0);
        detach_dev(t1);
        detach_dev(b1);
        detach_dev(t3);
        detach_dev(b2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(8:8) {#if $rowCount.total > 0}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let aside;
  let aside_class_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*small*/
      ctx2[1]
    )
      return create_if_block2;
    if (
      /*$rowCount*/
      ctx2[2].total > 0
    )
      return create_if_block_2;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      aside = element("aside");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      if_block.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "class", aside_class_value = null_to_empty(
        /*$$props*/
        ctx[4].class ?? ""
      ) + " svelte-9akqhk");
      add_location(aside, file4, 5, 0, 110);
      add_location(aside, file4, 5, 0, 110);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if_block.m(aside, null);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(aside, null);
        }
      }
      if (dirty & /*$$props*/
      16 && aside_class_value !== (aside_class_value = null_to_empty(
        /*$$props*/
        ctx2[4].class ?? ""
      ) + " svelte-9akqhk")) {
        attr_dev(aside, "class", aside_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $rowCount;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RowCount", slots, []);
  let { handler } = $$props;
  let { small = false } = $$props;
  const rowCount = handler.getRowCount();
  validate_store(rowCount, "rowCount");
  component_subscribe($$self, rowCount, (value) => $$invalidate(2, $rowCount = value));
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<RowCount> was created without expected prop 'handler'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props)
      $$invalidate(1, small = $$new_props.small);
  };
  $$self.$capture_state = () => ({ handler, small, rowCount, $rowCount });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$props)
      $$invalidate(1, small = $$new_props.small);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [handler, small, $rowCount, rowCount, $$props];
}
var RowCount = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { handler: 0, small: 1 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RowCount",
      options,
      id: create_fragment4.name
    });
  }
  get handler() {
    throw new Error("<RowCount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<RowCount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<RowCount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<RowCount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RowCount_default = RowCount;

// node_modules/@vincjo/datatables/dist/local/RowsPerPage.svelte
var file5 = "node_modules\\@vincjo\\datatables\\dist\\local\\RowsPerPage.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1n36gwj", "aside.svelte-1n36gwj{display:flex;justify-content:flex-start;align-items:center;height:32px;color:#757575}select.svelte-1n36gwj{margin:0 4px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm93c1BlclBhZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRGVza3RvcFxcZGF0YWJhc2VfcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxAdmluY2pvXFxkYXRhdGFibGVzXFxkaXN0XFxsb2NhbFxcUm93c1BlclBhZ2Uuc3ZlbHRlIl19 */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let span;
  let t_value = (
    /*handler*/
    ctx[0].i18n.show + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file5, 8, 8, 218);
      add_location(span, file5, 8, 8, 218);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.show + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(8:4) {#if !small}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let option_1;
  let t0_value = (
    /*option*/
    ctx[8] + ""
  );
  let t0;
  let t1;
  let option_1_value_value;
  const block = {
    c: function create() {
      option_1 = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option_1 = claim_element(nodes, "OPTION", {});
      var option_1_nodes = children(option_1);
      t0 = claim_text(option_1_nodes, t0_value);
      t1 = claim_space(option_1_nodes);
      option_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option_1.__value = option_1_value_value = /*option*/
      ctx[8];
      set_input_value(option_1, option_1.__value);
      add_location(option_1, file5, 12, 12, 387);
      add_location(option_1, file5, 12, 12, 387);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option_1, anchor);
      append_hydration_dev(option_1, t0);
      append_hydration_dev(option_1, t1);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(12:8) {#each options as option}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let span;
  let t_value = (
    /*handler*/
    ctx[0].i18n.entries + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file5, 18, 8, 519);
      add_location(span, file5, 18, 8, 519);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.entries + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(18:4) {#if !small}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let aside;
  let t0;
  let select;
  let t1;
  let aside_class_value;
  let mounted;
  let dispose;
  let if_block0 = !/*small*/
  ctx[1] && create_if_block_12(ctx);
  let each_value = ensure_array_like_dev(
    /*options*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  let if_block1 = !/*small*/
  ctx[1] && create_if_block3(ctx);
  const block = {
    c: function create() {
      aside = element("aside");
      if (if_block0)
        if_block0.c();
      t0 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      if (if_block0)
        if_block0.l(aside_nodes);
      t0 = claim_space(aside_nodes);
      select = claim_element(aside_nodes, "SELECT", { class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      t1 = claim_space(aside_nodes);
      if (if_block1)
        if_block1.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select, "class", "svelte-1n36gwj");
      if (
        /*$rowsPerPage*/
        ctx[2] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[6].call(select)
        ));
      add_location(select, file5, 10, 4, 267);
      add_location(select, file5, 10, 4, 267);
      attr_dev(aside, "class", aside_class_value = null_to_empty(
        /*$$props*/
        ctx[5].class ?? ""
      ) + " svelte-1n36gwj");
      add_location(aside, file5, 6, 0, 155);
      add_location(aside, file5, 6, 0, 155);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (if_block0)
        if_block0.m(aside, null);
      append_hydration_dev(aside, t0);
      append_hydration_dev(aside, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*$rowsPerPage*/
        ctx[2],
        true
      );
      append_hydration_dev(aside, t1);
      if (if_block1)
        if_block1.m(aside, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[6]
          ),
          listen_dev(
            select,
            "change",
            /*change_handler*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*small*/
      ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          if_block0.m(aside, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*options*/
      16) {
        each_value = ensure_array_like_dev(
          /*options*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$rowsPerPage, options*/
      20) {
        select_option(
          select,
          /*$rowsPerPage*/
          ctx2[2]
        );
      }
      if (!/*small*/
      ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          if_block1.m(aside, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$$props*/
      32 && aside_class_value !== (aside_class_value = null_to_empty(
        /*$$props*/
        ctx2[5].class ?? ""
      ) + " svelte-1n36gwj")) {
        attr_dev(aside, "class", aside_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let $rowsPerPage;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RowsPerPage", slots, []);
  let { handler } = $$props;
  let { small = false } = $$props;
  const rowsPerPage = handler.getRowsPerPage();
  validate_store(rowsPerPage, "rowsPerPage");
  component_subscribe($$self, rowsPerPage, (value) => $$invalidate(2, $rowsPerPage = value));
  const options = [5, 10, 20, 50, 100];
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<RowsPerPage> was created without expected prop 'handler'");
    }
  });
  function select_change_handler() {
    $rowsPerPage = select_value(this);
    rowsPerPage.set($rowsPerPage);
    $$invalidate(4, options);
  }
  const change_handler = () => handler.setPage(1);
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props)
      $$invalidate(1, small = $$new_props.small);
  };
  $$self.$capture_state = () => ({
    handler,
    small,
    rowsPerPage,
    options,
    $rowsPerPage
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$props)
      $$invalidate(1, small = $$new_props.small);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    handler,
    small,
    $rowsPerPage,
    rowsPerPage,
    options,
    $$props,
    select_change_handler,
    change_handler
  ];
}
var RowsPerPage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { handler: 0, small: 1 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RowsPerPage",
      options,
      id: create_fragment5.name
    });
  }
  get handler() {
    throw new Error("<RowsPerPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<RowsPerPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<RowsPerPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<RowsPerPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RowsPerPage_default = RowsPerPage;

// node_modules/@vincjo/datatables/dist/local/Search.svelte
var file6 = "node_modules\\@vincjo\\datatables\\dist\\local\\Search.svelte";
function add_css6(target) {
  append_styles(target, "svelte-m6fn8w", "input.svelte-m6fn8w{border:1px solid #e0e0e0;border-radius:4px;outline:none;padding:0 8px;line-height:24px;margin:0;height:24px;background:transparent;width:40%;max-width:176px;min-width:96px;transition:all, 0.1s}input.svelte-m6fn8w:focus{border:1px solid #bdbdbd}input.svelte-m6fn8w::-moz-placeholder{color:#9e9e9e;line-height:24px}input.svelte-m6fn8w::placeholder{color:#9e9e9e;line-height:24px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERlc2t0b3BcXGRhdGFiYXNlX3Byb2plY3RcXG5vZGVfbW9kdWxlc1xcQHZpbmNqb1xcZGF0YXRhYmxlc1xcZGlzdFxcbG9jYWxcXFNlYXJjaC5zdmVsdGUiXX0= */");
}
function create_fragment6(ctx) {
  let input;
  let input_class_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        placeholder: true,
        spellcheck: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", input_class_value = null_to_empty(
        /*$$props*/
        ctx[2].class ?? ""
      ) + " svelte-m6fn8w");
      attr_dev(input, "placeholder", input_placeholder_value = /*handler*/
      ctx[0].i18n.search);
      attr_dev(input, "spellcheck", "false");
      add_location(input, file6, 5, 0, 105);
      add_location(input, file6, 5, 0, 105);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[1]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$$props*/
      4 && input_class_value !== (input_class_value = null_to_empty(
        /*$$props*/
        ctx2[2].class ?? ""
      ) + " svelte-m6fn8w")) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*handler*/
      1 && input_placeholder_value !== (input_placeholder_value = /*handler*/
      ctx2[0].i18n.search)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        set_input_value(
          input,
          /*value*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Search", slots, []);
  let { handler } = $$props;
  let value = "";
  handler.on("clearSearch", () => $$invalidate(1, value = ""));
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<Search> was created without expected prop 'handler'");
    }
  });
  function input_input_handler() {
    value = this.value;
    $$invalidate(1, value);
  }
  const input_handler = () => handler.search(value);
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
  };
  $$self.$capture_state = () => ({ handler, value });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [handler, value, $$props, input_input_handler, input_handler];
}
var Search = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { handler: 0 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search",
      options,
      id: create_fragment6.name
    });
  }
  get handler() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Search_default = Search;

// node_modules/@vincjo/datatables/dist/local/Datatable.svelte
var file7 = "node_modules\\@vincjo\\datatables\\dist\\local\\Datatable.svelte";
function add_css7(target) {
  append_styles(target, "svelte-1nur0dj", "section.svelte-1nur0dj{height:100%}section.svelte-1nur0dj table{border-collapse:separate;border-spacing:0;width:100%}section.svelte-1nur0dj thead{position:sticky;inset-block-start:0;z-index:1}header.svelte-1nur0dj,footer.svelte-1nur0dj{min-height:8px;padding:0 16px;display:flex;justify-content:space-between;align-items:center}header.container.svelte-1nur0dj,footer.container.svelte-1nur0dj{height:48px}footer.svelte-1nur0dj{border-top:1px solid #e0e0e0}article.svelte-1nur0dj{position:relative;overflow:auto;scrollbar-width:thin}article.svelte-1nur0dj::-webkit-scrollbar{width:6px;height:6px}article.svelte-1nur0dj::-webkit-scrollbar-track{background:#f5f5f5}article.svelte-1nur0dj::-webkit-scrollbar-thumb{background:#c2c2c2}article.svelte-1nur0dj::-webkit-scrollbar-thumb:hover{background:#9e9e9e}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0YXRhYmxlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERlc2t0b3BcXGRhdGFiYXNlX3Byb2plY3RcXG5vZGVfbW9kdWxlc1xcQHZpbmNqb1xcZGF0YXRhYmxlc1xcZGlzdFxcbG9jYWxcXERhdGF0YWJsZS5zdmVsdGUiXX0= */");
}
function create_if_block_3(ctx) {
  let search_1;
  let current;
  search_1 = new Search_default({
    props: { handler: (
      /*handler*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(search_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(search_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(search_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const search_1_changes = {};
      if (dirty & /*handler*/
      1)
        search_1_changes.handler = /*handler*/
        ctx2[0];
      search_1.$set(search_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(search_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(18:8) {#if search}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let rowsperpage;
  let current;
  rowsperpage = new RowsPerPage_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[6] < 600
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rowsperpage.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rowsperpage.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rowsperpage, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rowsperpage_changes = {};
      if (dirty & /*handler*/
      1)
        rowsperpage_changes.handler = /*handler*/
        ctx2[0];
      if (dirty & /*clientWidth*/
      64)
        rowsperpage_changes.small = /*clientWidth*/
        ctx2[6] < 600;
      rowsperpage.$set(rowsperpage_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rowsperpage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rowsperpage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rowsperpage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(21:8) {#if rowsPerPage}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let rowcount;
  let current;
  rowcount = new RowCount_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[6] < 600
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rowcount.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rowcount.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rowcount, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rowcount_changes = {};
      if (dirty & /*handler*/
      1)
        rowcount_changes.handler = /*handler*/
        ctx2[0];
      if (dirty & /*clientWidth*/
      64)
        rowcount_changes.small = /*clientWidth*/
        ctx2[6] < 600;
      rowcount.$set(rowcount_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rowcount.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rowcount.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rowcount, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(31:8) {#if rowCount}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let pagination_1;
  let current;
  pagination_1 = new Pagination_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[6] < 600
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(pagination_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(pagination_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(pagination_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const pagination_1_changes = {};
      if (dirty & /*handler*/
      1)
        pagination_1_changes.handler = /*handler*/
        ctx2[0];
      if (dirty & /*clientWidth*/
      64)
        pagination_1_changes.small = /*clientWidth*/
        ctx2[6] < 600;
      pagination_1.$set(pagination_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pagination_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pagination_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pagination_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(34:8) {#if pagination}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let section;
  let header;
  let t0;
  let t1;
  let article;
  let t2;
  let footer;
  let t3;
  let section_class_value;
  let section_resize_listener;
  let current;
  let if_block0 = (
    /*search*/
    ctx[1] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*rowsPerPage*/
    ctx[2] && create_if_block_22(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let if_block2 = (
    /*rowCount*/
    ctx[3] && create_if_block_13(ctx)
  );
  let if_block3 = (
    /*pagination*/
    ctx[4] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      section = element("section");
      header = element("header");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      article = element("article");
      if (default_slot)
        default_slot.c();
      t2 = space();
      footer = element("footer");
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      header = claim_element(section_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if (if_block0)
        if_block0.l(header_nodes);
      t0 = claim_space(header_nodes);
      if (if_block1)
        if_block1.l(header_nodes);
      header_nodes.forEach(detach_dev);
      t1 = claim_space(section_nodes);
      article = claim_element(section_nodes, "ARTICLE", { style: true, class: true });
      var article_nodes = children(article);
      if (default_slot)
        default_slot.l(article_nodes);
      article_nodes.forEach(detach_dev);
      t2 = claim_space(section_nodes);
      footer = claim_element(section_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if (if_block2)
        if_block2.l(footer_nodes);
      t3 = claim_space(footer_nodes);
      if (if_block3)
        if_block3.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", "svelte-1nur0dj");
      toggle_class(
        header,
        "container",
        /*search*/
        ctx[1] || /*rowsPerPage*/
        ctx[2]
      );
      add_location(header, file7, 16, 4, 496);
      add_location(header, file7, 16, 4, 496);
      set_style(article, "height", "calc(100% - " + /*height*/
      ctx[7] + "px)");
      attr_dev(article, "class", "svelte-1nur0dj");
      add_location(article, file7, 25, 4, 745);
      add_location(article, file7, 25, 4, 745);
      attr_dev(footer, "class", "svelte-1nur0dj");
      toggle_class(
        footer,
        "container",
        /*rowCount*/
        ctx[3] || /*pagination*/
        ctx[4]
      );
      add_location(footer, file7, 29, 4, 855);
      add_location(footer, file7, 29, 4, 855);
      attr_dev(section, "class", section_class_value = null_to_empty(
        /*$$props*/
        ctx[8].class ?? ""
      ) + " svelte-1nur0dj");
      add_render_callback(() => (
        /*section_elementresize_handler*/
        ctx[12].call(section)
      ));
      add_location(section, file7, 15, 0, 436);
      add_location(section, file7, 15, 0, 436);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      append_hydration_dev(section, header);
      if (if_block0)
        if_block0.m(header, null);
      append_hydration_dev(header, t0);
      if (if_block1)
        if_block1.m(header, null);
      append_hydration_dev(section, t1);
      append_hydration_dev(section, article);
      if (default_slot) {
        default_slot.m(article, null);
      }
      ctx[11](article);
      append_hydration_dev(section, t2);
      append_hydration_dev(section, footer);
      if (if_block2)
        if_block2.m(footer, null);
      append_hydration_dev(footer, t3);
      if (if_block3)
        if_block3.m(footer, null);
      section_resize_listener = add_iframe_resize_listener(
        section,
        /*section_elementresize_handler*/
        ctx[12].bind(section)
      );
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*search*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*search*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(header, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*rowsPerPage*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*rowsPerPage*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(header, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*search, rowsPerPage*/
      6) {
        toggle_class(
          header,
          "container",
          /*search*/
          ctx2[1] || /*rowsPerPage*/
          ctx2[2]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*rowCount*/
        ctx2[3]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*rowCount*/
          8) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_13(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(footer, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*pagination*/
        ctx2[4]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*pagination*/
          16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block4(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(footer, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*rowCount, pagination*/
      24) {
        toggle_class(
          footer,
          "container",
          /*rowCount*/
          ctx2[3] || /*pagination*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*$$props*/
      256 && section_class_value !== (section_class_value = null_to_empty(
        /*$$props*/
        ctx2[8].class ?? ""
      ) + " svelte-1nur0dj")) {
        attr_dev(section, "class", section_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[11](null);
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      section_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Datatable", slots, ["default"]);
  let { handler } = $$props;
  let { search = true } = $$props;
  let { rowsPerPage = true } = $$props;
  let { rowCount = true } = $$props;
  let { pagination = true } = $$props;
  let element2;
  let clientWidth = 1e3;
  const height = (search || rowsPerPage ? 48 : 8) + (rowCount || pagination ? 48 : 8);
  handler.on("change", () => {
    if (element2)
      $$invalidate(5, element2.scrollTop = 0, element2);
  });
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<Datatable> was created without expected prop 'handler'");
    }
  });
  function article_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  function section_elementresize_handler() {
    clientWidth = this.clientWidth;
    $$invalidate(6, clientWidth);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("search" in $$new_props)
      $$invalidate(1, search = $$new_props.search);
    if ("rowsPerPage" in $$new_props)
      $$invalidate(2, rowsPerPage = $$new_props.rowsPerPage);
    if ("rowCount" in $$new_props)
      $$invalidate(3, rowCount = $$new_props.rowCount);
    if ("pagination" in $$new_props)
      $$invalidate(4, pagination = $$new_props.pagination);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Search: Search_default,
    RowsPerPage: RowsPerPage_default,
    RowCount: RowCount_default,
    Pagination: Pagination_default,
    handler,
    search,
    rowsPerPage,
    rowCount,
    pagination,
    element: element2,
    clientWidth,
    height
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("search" in $$props)
      $$invalidate(1, search = $$new_props.search);
    if ("rowsPerPage" in $$props)
      $$invalidate(2, rowsPerPage = $$new_props.rowsPerPage);
    if ("rowCount" in $$props)
      $$invalidate(3, rowCount = $$new_props.rowCount);
    if ("pagination" in $$props)
      $$invalidate(4, pagination = $$new_props.pagination);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("clientWidth" in $$props)
      $$invalidate(6, clientWidth = $$new_props.clientWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    handler,
    search,
    rowsPerPage,
    rowCount,
    pagination,
    element2,
    clientWidth,
    height,
    $$props,
    $$scope,
    slots,
    article_binding,
    section_elementresize_handler
  ];
}
var Datatable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        handler: 0,
        search: 1,
        rowsPerPage: 2,
        rowCount: 3,
        pagination: 4
      },
      add_css7
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Datatable",
      options,
      id: create_fragment7.name
    });
  }
  get handler() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get search() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set search(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowsPerPage() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowsPerPage(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowCount() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowCount(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pagination() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pagination(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Datatable_default = Datatable;
export {
  DataHandler,
  Datatable_default as Datatable,
  Pagination_default as Pagination,
  RowCount_default as RowCount,
  RowsPerPage_default as RowsPerPage,
  Search_default as Search,
  Th_default as Th,
  ThFilter_default as ThFilter,
  check
};
//# sourceMappingURL=@vincjo_datatables.js.map
