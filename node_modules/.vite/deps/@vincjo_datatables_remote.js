import "./chunk-NNUTDUNN.js";
import {
  derived,
  writable
} from "./chunk-5FHGK5EI.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_iframe_resize_listener,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_text,
  component_subscribe,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  get_svelte_dataset,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-X3RIRSZQ.js";
import "./chunk-YK27YCQ4.js";
import {
  __publicField
} from "./chunk-TYRVL62N.js";

// node_modules/@vincjo/datatables/dist/remote/handlers/EventHandler.js
var EventHandler = class {
  constructor() {
    __publicField(this, "events", {
      change: [],
      clearFilters: [],
      clearSearch: []
    });
    __publicField(this, "triggerChange", writable(0));
  }
  // legacy
  add(event, callback) {
    this.events[event].push(callback);
  }
  trigger(event) {
    for (const callback of this.events[event]) {
      callback();
    }
    if (event === "change") {
      this.triggerChange.update((store) => {
        return store + 1;
      });
    }
  }
};

// node_modules/@vincjo/datatables/dist/remote/Context.js
var Context = class {
  constructor(data, params) {
    __publicField(this, "totalRows");
    __publicField(this, "rowsPerPage");
    __publicField(this, "pageNumber");
    __publicField(this, "event");
    __publicField(this, "search");
    __publicField(this, "filters");
    __publicField(this, "rows");
    __publicField(this, "rowCount");
    __publicField(this, "pages");
    __publicField(this, "pagesWithEllipsis");
    __publicField(this, "pageCount");
    __publicField(this, "sort");
    __publicField(this, "selected");
    __publicField(this, "isAllSelected");
    __publicField(this, "selectedCount");
    __publicField(this, "selectBy");
    this.totalRows = writable(params.totalRows);
    this.rowsPerPage = writable(params.rowsPerPage);
    this.pageNumber = writable(1);
    this.event = new EventHandler();
    this.search = writable("");
    this.filters = writable([]);
    this.rows = writable(data);
    this.rowCount = this.createRowCount();
    this.pages = this.createPages();
    this.pagesWithEllipsis = this.createPagesWithEllipsis();
    this.pageCount = this.createPageCount();
    this.sort = writable(void 0);
    this.selected = writable([]);
    this.isAllSelected = this.createIsAllSelected();
    this.selectedCount = this.createSelectedCount();
    this.selectBy = params.selectBy ?? void 0;
  }
  getState() {
    const pageNumber = get_store_value(this.pageNumber);
    const rowsPerPage = get_store_value(this.rowsPerPage);
    const sort = get_store_value(this.sort);
    const filters = get_store_value(this.filters);
    return {
      pageNumber,
      rowsPerPage,
      offset: rowsPerPage * (pageNumber - 1),
      search: get_store_value(this.search),
      sorted: sort ?? void 0,
      sort: sort ?? void 0,
      filters: filters.length > 0 ? filters : void 0,
      setTotalRows: (value) => this.totalRows.set(value)
    };
  }
  createPages() {
    return derived([this.rowsPerPage, this.totalRows], ([$rowsPerPage, $totalRows]) => {
      if (!$rowsPerPage || !$totalRows) {
        return void 0;
      }
      const pages = Array.from(Array(Math.ceil($totalRows / $rowsPerPage)));
      return pages.map((_, i) => {
        return i + 1;
      });
    });
  }
  createPagesWithEllipsis() {
    return derived([this.pages, this.pageNumber], ([$pages, $pageNumber]) => {
      if (!$pages) {
        return void 0;
      }
      if ($pages.length <= 7) {
        return $pages;
      }
      const ellipse = null;
      const firstPage = 1;
      const lastPage = $pages.length;
      if ($pageNumber <= 4) {
        return [
          ...$pages.slice(0, 5),
          ellipse,
          lastPage
        ];
      } else if ($pageNumber < $pages.length - 3) {
        return [
          firstPage,
          ellipse,
          ...$pages.slice($pageNumber - 2, $pageNumber + 1),
          ellipse,
          lastPage
        ];
      } else {
        return [
          firstPage,
          ellipse,
          ...$pages.slice($pages.length - 5, $pages.length)
        ];
      }
    });
  }
  createPageCount() {
    return derived(this.pages, ($pages) => {
      if (!$pages)
        return void 0;
      return $pages.length;
    });
  }
  createRowCount() {
    return derived([this.totalRows, this.pageNumber, this.rowsPerPage], ([$totalRows, $pageNumber, $rowsPerPage]) => {
      if (!$rowsPerPage || !$totalRows) {
        return void 0;
      }
      return {
        total: $totalRows,
        start: $pageNumber * $rowsPerPage - $rowsPerPage + 1,
        end: Math.min($pageNumber * $rowsPerPage, $totalRows)
      };
    });
  }
  createIsAllSelected() {
    return derived([this.selected, this.rows], ([$selected, $rows]) => {
      if ($rows.length === 0) {
        return false;
      }
      if (this.selectBy) {
        const ids = $rows.map((row) => row[this.selectBy]);
        return ids.every((id) => $selected.includes(id));
      }
      return $rows.every((row) => $selected.includes(row));
    });
  }
  createSelectedCount() {
    return derived([this.selected, this.totalRows], ([$selected, $totalRows]) => {
      return {
        count: $selected.length,
        total: $totalRows
      };
    });
  }
};

// node_modules/@vincjo/datatables/dist/remote/handlers/TriggerHandler.js
var TriggerHandler = class {
  constructor(context) {
    __publicField(this, "context");
    __publicField(this, "reload");
    this.context = context;
  }
  set(callback) {
    this.reload = callback;
  }
  async invalidate() {
    if (!this.reload)
      return;
    const state = this.context.getState();
    const data = await this.reload(state);
    if (data) {
      this.context.rows.set(data);
    }
  }
};

// node_modules/@vincjo/datatables/dist/remote/handlers/SortHandler.js
var SortHandler = class {
  constructor(context) {
    __publicField(this, "event");
    __publicField(this, "hasMultipleSort");
    __publicField(this, "sort");
    this.event = context.event;
    this.hasMultipleSort = false;
    this.sort = context.sort;
  }
  set(orderBy = null) {
    if (!orderBy)
      return;
    const sort = get_store_value(this.sort);
    if (!sort || sort.orderBy !== orderBy) {
      this.asc(orderBy);
    } else if (sort.direction === "asc") {
      this.desc(sort.orderBy);
    } else if (sort.direction === "desc") {
      this.asc(orderBy);
    }
  }
  asc(orderBy) {
    if (!orderBy)
      return;
    this.sort.set({ orderBy, direction: "asc" });
    this.event.trigger("change");
  }
  desc(orderBy) {
    if (!orderBy)
      return;
    this.sort.set({ orderBy, direction: "desc" });
    this.event.trigger("change");
  }
  apply(params = null) {
    if (params) {
      switch (params.direction) {
        case "asc":
          return this.asc(params.orderBy);
        case "desc":
          return this.desc(params.orderBy);
        default:
          return this.set(params.orderBy);
      }
    }
    const sort = get_store_value(this.sort);
    if (sort) {
      return this.apply({ orderBy: sort.orderBy, direction: sort.direction });
    }
    return;
  }
};

// node_modules/@vincjo/datatables/dist/remote/handlers/SelectHandler.js
var SelectHandler = class {
  constructor(context) {
    __publicField(this, "rows");
    __publicField(this, "selected");
    __publicField(this, "isAllSelected");
    __publicField(this, "selectBy");
    this.rows = context.rows;
    this.selected = context.selected;
    this.isAllSelected = context.isAllSelected;
    this.selectBy = context.selectBy;
  }
  set(value) {
    const selected = get_store_value(this.selected);
    if (selected.includes(value)) {
      this.selected.set(selected.filter((item) => item !== value));
    } else {
      this.selected.set([value, ...selected]);
    }
  }
  all() {
    const rows = get_store_value(this.rows);
    const isAllSelected = get_store_value(this.isAllSelected);
    this.selected.update((store) => {
      if (this.selectBy) {
        return store = store.filter((item) => !rows.map((row) => row[this.selectBy]).includes(item));
      }
      return store = store.filter((item) => !rows.includes(item));
    });
    if (!isAllSelected) {
      this.selected.update((store) => {
        if (this.selectBy) {
          store = [...rows.map((row) => row[this.selectBy]), ...store];
        } else {
          store = [...rows, ...store];
        }
        return store;
      });
    }
  }
  clear() {
    this.selected.set([]);
  }
};

// node_modules/@vincjo/datatables/dist/remote/handlers/PageHandler.js
var PageHandler = class {
  constructor(context) {
    __publicField(this, "totalRows");
    __publicField(this, "pageNumber");
    __publicField(this, "rowCount");
    __publicField(this, "rowsPerPage");
    __publicField(this, "event");
    __publicField(this, "pages");
    __publicField(this, "selected");
    this.totalRows = context.totalRows;
    this.pageNumber = context.pageNumber;
    this.rowCount = context.rowCount;
    this.rowsPerPage = context.rowsPerPage;
    this.event = context.event;
    this.pages = context.pages;
    this.selected = context.selected;
  }
  get() {
    return this.pages;
  }
  goto(number) {
    const rowsPerPage = get_store_value(this.rowsPerPage);
    const totalRows = get_store_value(this.totalRows);
    this.pageNumber.update((store) => {
      if (rowsPerPage && totalRows) {
        if (number >= 1 && number <= Math.ceil(totalRows / rowsPerPage)) {
          store = number;
          this.event.trigger("change");
        }
        return store;
      } else {
        if (number >= 1) {
          store = number;
          this.event.trigger("change");
        }
        return store;
      }
    });
  }
  previous() {
    const number = get_store_value(this.pageNumber) - 1;
    this.goto(number);
  }
  next() {
    const number = get_store_value(this.pageNumber) + 1;
    this.goto(number);
  }
};

// node_modules/@vincjo/datatables/dist/remote/handlers/SearchHandler.js
var SearchHandler = class {
  constructor(context) {
    __publicField(this, "search");
    this.search = context.search;
  }
  set(value) {
    this.search.set(value ?? null);
  }
  remove() {
    this.search.set(null);
  }
};

// node_modules/@vincjo/datatables/dist/remote/handlers/FilterHandler.js
var FilterHandler = class {
  constructor(context) {
    __publicField(this, "filters");
    this.filters = context.filters;
  }
  set(value, filterBy) {
    const filter = { filterBy, value };
    this.filters.update((store) => {
      store = store.filter((item) => {
        return item.filterBy !== filterBy && item.value;
      });
      if (value) {
        store.push(filter);
      }
      return store;
    });
  }
  remove() {
    this.filters.set([]);
  }
};

// node_modules/@vincjo/datatables/dist/remote/DataHandler.js
var DataHandler = class {
  constructor(data = [], params = { rowsPerPage: 5 }) {
    __publicField(this, "context");
    __publicField(this, "triggerHandler");
    __publicField(this, "sortHandler");
    __publicField(this, "selectHandler");
    __publicField(this, "pageHandler");
    __publicField(this, "searchHandler");
    __publicField(this, "filterHandler");
    __publicField(this, "i18n");
    this.i18n = this.translate(params.i18n);
    this.context = new Context(data, params);
    this.triggerHandler = new TriggerHandler(this.context);
    this.sortHandler = new SortHandler(this.context);
    this.selectHandler = new SelectHandler(this.context);
    this.pageHandler = new PageHandler(this.context);
    this.searchHandler = new SearchHandler(this.context);
    this.filterHandler = new FilterHandler(this.context);
  }
  onChange(callback) {
    this.triggerHandler.set(callback);
  }
  invalidate() {
    this.triggerHandler.invalidate();
  }
  setRows(data) {
    this.context.rows.set(data);
  }
  setTotalRows(value) {
    this.context.totalRows.set(value);
  }
  getRows() {
    return this.context.rows;
  }
  select(value) {
    this.selectHandler.set(value);
  }
  getSelected() {
    return this.context.selected;
  }
  selectAll() {
    this.selectHandler.all();
  }
  isAllSelected() {
    return this.context.isAllSelected;
  }
  getSelectedCount() {
    return this.context.selectedCount;
  }
  clearSelection() {
    this.selectHandler.clear();
  }
  getRowsPerPage() {
    return this.context.rowsPerPage;
  }
  sort(orderBy) {
    this.setPage(1);
    this.sortHandler.set(orderBy);
  }
  applySort(params = null) {
    this.sortHandler.apply(params);
  }
  sortAsc(orderBy) {
    this.setPage(1);
    this.sortHandler.asc(orderBy);
  }
  sortDesc(orderBy) {
    this.setPage(1);
    this.sortHandler.desc(orderBy);
  }
  getSort() {
    return this.context.sort;
  }
  search(value) {
    this.setPage(1);
    this.context.search.set(value);
  }
  clearSearch() {
    this.searchHandler.remove();
  }
  filter(value, filterBy) {
    this.setPage(1);
    return this.filterHandler.set(value, filterBy);
  }
  clearFilters() {
    this.filterHandler.remove();
  }
  getPages(params = { ellipsis: false }) {
    if (params.ellipsis) {
      return this.context.pagesWithEllipsis;
    }
    return this.context.pages;
  }
  getPageCount() {
    return this.context.pageCount;
  }
  getPageNumber() {
    return this.context.pageNumber;
  }
  setPage(value) {
    switch (value) {
      case "previous":
        return this.pageHandler.previous();
      case "next":
        return this.pageHandler.next();
      default:
        return this.pageHandler.goto(value);
    }
  }
  getRowCount() {
    return this.context.rowCount;
  }
  on(event, callback) {
    this.context.event.add(event, callback);
  }
  translate(i18n) {
    return {
      ...{
        search: "Search...",
        show: "Show",
        entries: "entries",
        filter: "Filter",
        rowCount: "Showing {start} to {end} of {total} entries",
        noRows: "No entries found",
        previous: "Previous",
        next: "Next",
        selectedCount: "{count} of {total} row(s)."
      },
      ...i18n
    };
  }
  /**
   *
   * @depracted use on('change', callback) instead
   */
  getTriggerChange() {
    return this.context.event.triggerChange;
  }
  /**
   *
   * @deprecated use applySort() instead
   */
  applySorting(params = null) {
    this.applySort(params);
  }
  /**
   *
   * @deprecated use getSort() instead
   */
  getSorted() {
    return this.getSort();
  }
};

// node_modules/@vincjo/datatables/dist/remote/Datatable.svelte
var file = "node_modules\\@vincjo\\datatables\\dist\\remote\\Datatable.svelte";
function add_css(target) {
  append_styles(target, "svelte-1nur0dj", "section.svelte-1nur0dj{height:100%}section.svelte-1nur0dj table{border-collapse:separate;border-spacing:0;width:100%}section.svelte-1nur0dj thead{position:sticky;inset-block-start:0;z-index:1}header.svelte-1nur0dj,footer.svelte-1nur0dj{min-height:8px;padding:0 16px;display:flex;justify-content:space-between;align-items:center}header.container.svelte-1nur0dj,footer.container.svelte-1nur0dj{height:48px}footer.svelte-1nur0dj{border-top:1px solid #e0e0e0}article.svelte-1nur0dj{position:relative;overflow:auto;scrollbar-width:thin}article.svelte-1nur0dj::-webkit-scrollbar{width:6px;height:6px}article.svelte-1nur0dj::-webkit-scrollbar-track{background:#f5f5f5}article.svelte-1nur0dj::-webkit-scrollbar-thumb{background:#c2c2c2}article.svelte-1nur0dj::-webkit-scrollbar-thumb:hover{background:#9e9e9e}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0YXRhYmxlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERlc2t0b3BcXGRhdGFiYXNlX3Byb2plY3RcXG5vZGVfbW9kdWxlc1xcQHZpbmNqb1xcZGF0YXRhYmxlc1xcZGlzdFxccmVtb3RlXFxEYXRhdGFibGUuc3ZlbHRlIl19 */");
}
function create_else_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file, 21, 12, 684);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(21:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let search_1;
  let current;
  search_1 = new Search_default({
    props: { handler: (
      /*handler*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(search_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(search_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(search_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const search_1_changes = {};
      if (dirty & /*handler*/
      1)
        search_1_changes.handler = /*handler*/
        ctx2[0];
      search_1.$set(search_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(search_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(search_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(search_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(19:8) {#if search}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let rowsperpage;
  let current;
  rowsperpage = new RowsPerPage_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[7] < 600
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rowsperpage.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rowsperpage.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rowsperpage, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rowsperpage_changes = {};
      if (dirty & /*handler*/
      1)
        rowsperpage_changes.handler = /*handler*/
        ctx2[0];
      if (dirty & /*clientWidth*/
      128)
        rowsperpage_changes.small = /*clientWidth*/
        ctx2[7] < 600;
      rowsperpage.$set(rowsperpage_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rowsperpage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rowsperpage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rowsperpage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(24:8) {#if rowsPerPage}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let rowcount;
  let current;
  rowcount = new RowCount_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[7] < 600
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rowcount.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(rowcount.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(rowcount, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rowcount_changes = {};
      if (dirty & /*handler*/
      1)
        rowcount_changes.handler = /*handler*/
        ctx2[0];
      if (dirty & /*clientWidth*/
      128)
        rowcount_changes.small = /*clientWidth*/
        ctx2[7] < 600;
      rowcount.$set(rowcount_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rowcount.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rowcount.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rowcount, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(36:27) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let selectedcount;
  let current;
  selectedcount = new SelectedCount_default({
    props: { handler: (
      /*handler*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(selectedcount.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(selectedcount.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(selectedcount, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const selectedcount_changes = {};
      if (dirty & /*handler*/
      1)
        selectedcount_changes.handler = /*handler*/
        ctx2[0];
      selectedcount.$set(selectedcount_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selectedcount.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selectedcount.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(selectedcount, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(34:8) {#if selectedCount}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let pagination_1;
  let current;
  pagination_1 = new Pagination_default({
    props: {
      handler: (
        /*handler*/
        ctx[0]
      ),
      small: (
        /*clientWidth*/
        ctx[7] < 600
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(pagination_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(pagination_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(pagination_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const pagination_1_changes = {};
      if (dirty & /*handler*/
      1)
        pagination_1_changes.handler = /*handler*/
        ctx2[0];
      if (dirty & /*clientWidth*/
      128)
        pagination_1_changes.small = /*clientWidth*/
        ctx2[7] < 600;
      pagination_1.$set(pagination_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pagination_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pagination_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pagination_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(39:8) {#if pagination}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let section;
  let header;
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let article;
  let t2;
  let footer;
  let current_block_type_index_1;
  let if_block2;
  let t3;
  let section_class_value;
  let section_resize_listener;
  let current;
  const if_block_creators = [create_if_block_4, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*search*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = (
    /*rowsPerPage*/
    ctx[2] && create_if_block_3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const if_block_creators_1 = [create_if_block_1, create_if_block_2];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*selectedCount*/
      ctx2[4]
    )
      return 0;
    if (
      /*rowCount*/
      ctx2[3]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index_1 = select_block_type_1(ctx, -1))) {
    if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  }
  let if_block3 = (
    /*pagination*/
    ctx[5] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      section = element("section");
      header = element("header");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      article = element("article");
      if (default_slot)
        default_slot.c();
      t2 = space();
      footer = element("footer");
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      header = claim_element(section_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if_block0.l(header_nodes);
      t0 = claim_space(header_nodes);
      if (if_block1)
        if_block1.l(header_nodes);
      header_nodes.forEach(detach_dev);
      t1 = claim_space(section_nodes);
      article = claim_element(section_nodes, "ARTICLE", { style: true, class: true });
      var article_nodes = children(article);
      if (default_slot)
        default_slot.l(article_nodes);
      article_nodes.forEach(detach_dev);
      t2 = claim_space(section_nodes);
      footer = claim_element(section_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      if (if_block2)
        if_block2.l(footer_nodes);
      t3 = claim_space(footer_nodes);
      if (if_block3)
        if_block3.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", "svelte-1nur0dj");
      toggle_class(
        header,
        "container",
        /*search*/
        ctx[1] || /*rowsPerPage*/
        ctx[2]
      );
      add_location(header, file, 17, 4, 549);
      set_style(article, "height", "calc(100% - " + /*height*/
      ctx[8] + "px)");
      attr_dev(article, "class", "svelte-1nur0dj");
      add_location(article, file, 28, 4, 835);
      attr_dev(footer, "class", "svelte-1nur0dj");
      toggle_class(
        footer,
        "container",
        /*rowCount*/
        ctx[3] || /*pagination*/
        ctx[5]
      );
      add_location(footer, file, 32, 4, 945);
      attr_dev(section, "class", section_class_value = null_to_empty(
        /*$$props*/
        ctx[9].class ?? ""
      ) + " svelte-1nur0dj");
      add_render_callback(() => (
        /*section_elementresize_handler*/
        ctx[13].call(section)
      ));
      add_location(section, file, 16, 0, 489);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      append_hydration_dev(section, header);
      if_blocks[current_block_type_index].m(header, null);
      append_hydration_dev(header, t0);
      if (if_block1)
        if_block1.m(header, null);
      append_hydration_dev(section, t1);
      append_hydration_dev(section, article);
      if (default_slot) {
        default_slot.m(article, null);
      }
      ctx[12](article);
      append_hydration_dev(section, t2);
      append_hydration_dev(section, footer);
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].m(footer, null);
      }
      append_hydration_dev(footer, t3);
      if (if_block3)
        if_block3.m(footer, null);
      section_resize_listener = add_iframe_resize_listener(
        section,
        /*section_elementresize_handler*/
        ctx[13].bind(section)
      );
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(header, t0);
      }
      if (
        /*rowsPerPage*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*rowsPerPage*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(header, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*search, rowsPerPage*/
      6) {
        toggle_class(
          header,
          "container",
          /*search*/
          ctx2[1] || /*rowsPerPage*/
          ctx2[2]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2, dirty);
      if (current_block_type_index_1 === previous_block_index_1) {
        if (~current_block_type_index_1) {
          if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
            if_blocks_1[previous_block_index_1] = null;
          });
          check_outros();
        }
        if (~current_block_type_index_1) {
          if_block2 = if_blocks_1[current_block_type_index_1];
          if (!if_block2) {
            if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(footer, t3);
        } else {
          if_block2 = null;
        }
      }
      if (
        /*pagination*/
        ctx2[5]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*pagination*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(footer, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*rowCount, pagination*/
      40) {
        toggle_class(
          footer,
          "container",
          /*rowCount*/
          ctx2[3] || /*pagination*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*$$props*/
      512 && section_class_value !== (section_class_value = null_to_empty(
        /*$$props*/
        ctx2[9].class ?? ""
      ) + " svelte-1nur0dj")) {
        attr_dev(section, "class", section_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].d();
      }
      if (if_block3)
        if_block3.d();
      section_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Datatable", slots, ["default"]);
  let { handler } = $$props;
  let { search = true } = $$props;
  let { rowsPerPage = true } = $$props;
  let { rowCount = true } = $$props;
  let { selectedCount = false } = $$props;
  let { pagination = true } = $$props;
  let element2;
  let clientWidth = 1e3;
  const height = (search || rowsPerPage ? 48 : 8) + (rowCount || selectedCount || pagination ? 48 : 8);
  handler.on("change", () => {
    if (element2)
      $$invalidate(6, element2.scrollTop = 0, element2);
  });
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<Datatable> was created without expected prop 'handler'");
    }
  });
  function article_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(6, element2);
    });
  }
  function section_elementresize_handler() {
    clientWidth = this.clientWidth;
    $$invalidate(7, clientWidth);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("search" in $$new_props)
      $$invalidate(1, search = $$new_props.search);
    if ("rowsPerPage" in $$new_props)
      $$invalidate(2, rowsPerPage = $$new_props.rowsPerPage);
    if ("rowCount" in $$new_props)
      $$invalidate(3, rowCount = $$new_props.rowCount);
    if ("selectedCount" in $$new_props)
      $$invalidate(4, selectedCount = $$new_props.selectedCount);
    if ("pagination" in $$new_props)
      $$invalidate(5, pagination = $$new_props.pagination);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    Search: Search_default,
    RowsPerPage: RowsPerPage_default,
    RowCount: RowCount_default,
    SelectedCount: SelectedCount_default,
    Pagination: Pagination_default,
    handler,
    search,
    rowsPerPage,
    rowCount,
    selectedCount,
    pagination,
    element: element2,
    clientWidth,
    height
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("search" in $$props)
      $$invalidate(1, search = $$new_props.search);
    if ("rowsPerPage" in $$props)
      $$invalidate(2, rowsPerPage = $$new_props.rowsPerPage);
    if ("rowCount" in $$props)
      $$invalidate(3, rowCount = $$new_props.rowCount);
    if ("selectedCount" in $$props)
      $$invalidate(4, selectedCount = $$new_props.selectedCount);
    if ("pagination" in $$props)
      $$invalidate(5, pagination = $$new_props.pagination);
    if ("element" in $$props)
      $$invalidate(6, element2 = $$new_props.element);
    if ("clientWidth" in $$props)
      $$invalidate(7, clientWidth = $$new_props.clientWidth);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    handler,
    search,
    rowsPerPage,
    rowCount,
    selectedCount,
    pagination,
    element2,
    clientWidth,
    height,
    $$props,
    $$scope,
    slots,
    article_binding,
    section_elementresize_handler
  ];
}
var Datatable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        handler: 0,
        search: 1,
        rowsPerPage: 2,
        rowCount: 3,
        selectedCount: 4,
        pagination: 5
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Datatable",
      options,
      id: create_fragment.name
    });
  }
  get handler() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get search() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set search(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowsPerPage() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowsPerPage(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowCount() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowCount(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedCount() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedCount(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pagination() {
    throw new Error("<Datatable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pagination(value) {
    throw new Error("<Datatable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Datatable_default = Datatable;

// node_modules/@vincjo/datatables/dist/remote/Search.svelte
var file2 = "node_modules\\@vincjo\\datatables\\dist\\remote\\Search.svelte";
function add_css2(target) {
  append_styles(target, "svelte-lioh12", "input.svelte-lioh12{border:1px solid #e0e0e0;border-radius:4px;outline:none;padding:0 8px;line-height:24px;margin:0;height:24px;background:transparent;width:40%;max-width:176px;min-width:96px;transition:all, 0.1s}input.svelte-lioh12:focus{border:1px solid #bdbdbd}input.svelte-lioh12::-moz-placeholder{color:#9e9e9e;line-height:24px}input.svelte-lioh12::placeholder{color:#9e9e9e;line-height:24px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VhcmNoLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJDOlxcVXNlcnNcXFVzZXJcXERlc2t0b3BcXGRhdGFiYXNlX3Byb2plY3RcXG5vZGVfbW9kdWxlc1xcQHZpbmNqb1xcZGF0YXRhYmxlc1xcZGlzdFxccmVtb3RlXFxTZWFyY2guc3ZlbHRlIl19 */");
}
function create_fragment2(ctx) {
  let input;
  let input_class_value;
  let input_placeholder_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        placeholder: true,
        spellcheck: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", input_class_value = null_to_empty(
        /*$$props*/
        ctx[3].class ?? ""
      ) + " svelte-lioh12");
      attr_dev(input, "placeholder", input_placeholder_value = /*handler*/
      ctx[0].i18n.search);
      attr_dev(input, "spellcheck", "false");
      add_location(input, file2, 12, 0, 226);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[1]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[4]
          ),
          listen_dev(
            input,
            "input",
            /*search*/
            ctx[2],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$$props*/
      8 && input_class_value !== (input_class_value = null_to_empty(
        /*$$props*/
        ctx2[3].class ?? ""
      ) + " svelte-lioh12")) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*handler*/
      1 && input_placeholder_value !== (input_placeholder_value = /*handler*/
      ctx2[0].i18n.search)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*value*/
      2 && input.value !== /*value*/
      ctx2[1]) {
        set_input_value(
          input,
          /*value*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Search", slots, []);
  let { handler } = $$props;
  let value = "";
  let timeout;
  const search = () => {
    handler.search(value);
    clearTimeout(timeout);
    timeout = setTimeout(
      () => {
        handler.invalidate();
      },
      400
    );
  };
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<Search> was created without expected prop 'handler'");
    }
  });
  function input_input_handler() {
    value = this.value;
    $$invalidate(1, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
  };
  $$self.$capture_state = () => ({ handler, value, timeout, search });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("value" in $$props)
      $$invalidate(1, value = $$new_props.value);
    if ("timeout" in $$props)
      timeout = $$new_props.timeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [handler, value, search, $$props, input_input_handler];
}
var Search = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { handler: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search",
      options,
      id: create_fragment2.name
    });
  }
  get handler() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Search_default = Search;

// node_modules/@vincjo/datatables/dist/remote/RowsPerPage.svelte
var file3 = "node_modules\\@vincjo\\datatables\\dist\\remote\\RowsPerPage.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1n36gwj", "aside.svelte-1n36gwj{display:flex;justify-content:flex-start;align-items:center;height:32px;color:#757575}select.svelte-1n36gwj{margin:0 4px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm93c1BlclBhZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRGVza3RvcFxcZGF0YWJhc2VfcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxAdmluY2pvXFxkYXRhdGFibGVzXFxkaXN0XFxyZW1vdGVcXFJvd3NQZXJQYWdlLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block_12(ctx) {
  let span;
  let t_value = (
    /*handler*/
    ctx[0].i18n.show + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file3, 12, 8, 294);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.show + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(12:4) {#if !small}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let option_1;
  let t0_value = (
    /*option*/
    ctx[8] + ""
  );
  let t0;
  let t1;
  let option_1_value_value;
  const block = {
    c: function create() {
      option_1 = element("option");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      option_1 = claim_element(nodes, "OPTION", {});
      var option_1_nodes = children(option_1);
      t0 = claim_text(option_1_nodes, t0_value);
      t1 = claim_space(option_1_nodes);
      option_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option_1.__value = option_1_value_value = /*option*/
      ctx[8];
      set_input_value(option_1, option_1.__value);
      add_location(option_1, file3, 16, 12, 453);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option_1, anchor);
      append_hydration_dev(option_1, t0);
      append_hydration_dev(option_1, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*options*/
      4 && t0_value !== (t0_value = /*option*/
      ctx2[8] + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*options*/
      4 && option_1_value_value !== (option_1_value_value = /*option*/
      ctx2[8])) {
        prop_dev(option_1, "__value", option_1_value_value);
        set_input_value(option_1, option_1.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(16:8) {#each options as option}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let span;
  let t_value = (
    /*handler*/
    ctx[0].i18n.entries + ""
  );
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file3, 22, 8, 585);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.entries + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(22:4) {#if !small}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let aside;
  let t0;
  let select;
  let t1;
  let aside_class_value;
  let mounted;
  let dispose;
  let if_block0 = !/*small*/
  ctx[1] && create_if_block_12(ctx);
  let each_value = ensure_array_like_dev(
    /*options*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let if_block1 = !/*small*/
  ctx[1] && create_if_block2(ctx);
  const block = {
    c: function create() {
      aside = element("aside");
      if (if_block0)
        if_block0.c();
      t0 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      if (if_block0)
        if_block0.l(aside_nodes);
      t0 = claim_space(aside_nodes);
      select = claim_element(aside_nodes, "SELECT", { class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      t1 = claim_space(aside_nodes);
      if (if_block1)
        if_block1.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select, "class", "svelte-1n36gwj");
      if (
        /*$rowsPerPage*/
        ctx[3] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[7].call(select)
        ));
      add_location(select, file3, 14, 4, 343);
      attr_dev(aside, "class", aside_class_value = null_to_empty(
        /*$$props*/
        ctx[6].class ?? ""
      ) + " svelte-1n36gwj");
      add_location(aside, file3, 10, 0, 231);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (if_block0)
        if_block0.m(aside, null);
      append_hydration_dev(aside, t0);
      append_hydration_dev(aside, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*$rowsPerPage*/
        ctx[3],
        true
      );
      append_hydration_dev(aside, t1);
      if (if_block1)
        if_block1.m(aside, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[7]
          ),
          listen_dev(
            select,
            "change",
            /*setRowsPerPage*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*small*/
      ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          if_block0.m(aside, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*options*/
      4) {
        each_value = ensure_array_like_dev(
          /*options*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*$rowsPerPage, options*/
      12) {
        select_option(
          select,
          /*$rowsPerPage*/
          ctx2[3]
        );
      }
      if (!/*small*/
      ctx2[1]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          if_block1.m(aside, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$$props*/
      64 && aside_class_value !== (aside_class_value = null_to_empty(
        /*$$props*/
        ctx2[6].class ?? ""
      ) + " svelte-1n36gwj")) {
        attr_dev(aside, "class", aside_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $rowsPerPage;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RowsPerPage", slots, []);
  let { handler } = $$props;
  let { small = false } = $$props;
  let { options = [5, 10, 20] } = $$props;
  const rowsPerPage = handler.getRowsPerPage();
  validate_store(rowsPerPage, "rowsPerPage");
  component_subscribe($$self, rowsPerPage, (value) => $$invalidate(3, $rowsPerPage = value));
  const setRowsPerPage = () => {
    handler.setPage(1);
    handler.invalidate();
  };
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<RowsPerPage> was created without expected prop 'handler'");
    }
  });
  function select_change_handler() {
    $rowsPerPage = select_value(this);
    rowsPerPage.set($rowsPerPage);
    $$invalidate(2, options);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props)
      $$invalidate(1, small = $$new_props.small);
    if ("options" in $$new_props)
      $$invalidate(2, options = $$new_props.options);
  };
  $$self.$capture_state = () => ({
    handler,
    small,
    options,
    rowsPerPage,
    setRowsPerPage,
    $rowsPerPage
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$props)
      $$invalidate(1, small = $$new_props.small);
    if ("options" in $$props)
      $$invalidate(2, options = $$new_props.options);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    handler,
    small,
    options,
    $rowsPerPage,
    rowsPerPage,
    setRowsPerPage,
    $$props,
    select_change_handler
  ];
}
var RowsPerPage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { handler: 0, small: 1, options: 2 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RowsPerPage",
      options,
      id: create_fragment3.name
    });
  }
  get handler() {
    throw new Error("<RowsPerPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<RowsPerPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<RowsPerPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<RowsPerPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<RowsPerPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<RowsPerPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RowsPerPage_default = RowsPerPage;

// node_modules/@vincjo/datatables/dist/remote/Th.svelte
var file4 = "node_modules\\@vincjo\\datatables\\dist\\remote\\Th.svelte";
function add_css4(target) {
  append_styles(target, "svelte-cur88x", "th.svelte-cur88x.svelte-cur88x{background:inherit;padding:8px 20px;white-space:nowrap;font-size:13px;-webkit-user-select:none;-moz-user-select:none;user-select:none;border-bottom:1px solid #e0e0e0}th.sortable.svelte-cur88x.svelte-cur88x{cursor:pointer}th.svelte-cur88x strong.svelte-cur88x{white-space:pre-wrap;font-size:13.5px;line-height:16px}th.sortable.svelte-cur88x div.flex.svelte-cur88x{padding:0;display:flex;align-items:center;height:100%}th.sortable.svelte-cur88x span.svelte-cur88x{padding-left:8px}th.sortable.svelte-cur88x span.svelte-cur88x:before,th.sortable.svelte-cur88x span.svelte-cur88x:after{border:4px solid transparent;content:'';display:block;height:0;width:0}th.sortable.svelte-cur88x span.svelte-cur88x:before{border-bottom-color:#e0e0e0;margin-top:2px}th.sortable.svelte-cur88x span.svelte-cur88x:after{border-top-color:#e0e0e0;margin-top:2px}th.active.sortable.svelte-cur88x span.asc.svelte-cur88x:before{border-bottom-color:#9e9e9e}th.active.sortable.svelte-cur88x span.desc.svelte-cur88x:after{border-top-color:#9e9e9e}th.svelte-cur88x:not(.sortable) span.svelte-cur88x{visibility:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGguc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRGVza3RvcFxcZGF0YWJhc2VfcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxAdmluY2pvXFxkYXRhdGFibGVzXFxkaXN0XFxyZW1vdGVcXFRoLnN2ZWx0ZSJdfQ== */");
}
function create_fragment4(ctx) {
  let th;
  let div;
  let strong;
  let t;
  let span;
  let th_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const block = {
    c: function create() {
      th = element("th");
      div = element("div");
      strong = element("strong");
      if (default_slot)
        default_slot.c();
      t = space();
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, rowspan: true });
      var th_nodes = children(th);
      div = claim_element(th_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      strong = claim_element(div_nodes, "STRONG", { class: true });
      var strong_nodes = children(strong);
      if (default_slot)
        default_slot.l(strong_nodes);
      strong_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a, _b, _c;
      attr_dev(strong, "class", "svelte-cur88x");
      add_location(strong, file4, 22, 8, 543);
      attr_dev(span, "class", "svelte-cur88x");
      toggle_class(
        span,
        "asc",
        /*$sort*/
        ((_a = ctx[3]) == null ? void 0 : _a.direction) === "asc"
      );
      toggle_class(
        span,
        "desc",
        /*$sort*/
        ((_b = ctx[3]) == null ? void 0 : _b.direction) === "desc"
      );
      add_location(span, file4, 25, 8, 602);
      attr_dev(div, "class", "flex svelte-cur88x");
      set_style(
        div,
        "justify-content",
        /*align*/
        ctx[1] === "left" ? "flex-start" : (
          /*align*/
          ctx[1] === "right" ? "flex-end" : "center"
        )
      );
      add_location(div, file4, 18, 4, 391);
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*$$props*/
        ctx[6].class ?? ""
      ) + " svelte-cur88x");
      attr_dev(
        th,
        "rowspan",
        /*rowSpan*/
        ctx[2]
      );
      toggle_class(
        th,
        "sortable",
        /*orderBy*/
        ctx[0]
      );
      toggle_class(
        th,
        "active",
        /*$sort*/
        ((_c = ctx[3]) == null ? void 0 : _c.orderBy) === /*orderBy*/
        ctx[0]
      );
      add_location(th, file4, 11, 0, 223);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, div);
      append_hydration_dev(div, strong);
      if (default_slot) {
        default_slot.m(strong, null);
      }
      append_hydration_dev(div, t);
      append_hydration_dev(div, span);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          th,
          "click",
          /*update*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      var _a, _b, _c;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$sort*/
      8) {
        toggle_class(
          span,
          "asc",
          /*$sort*/
          ((_a = ctx2[3]) == null ? void 0 : _a.direction) === "asc"
        );
      }
      if (!current || dirty & /*$sort*/
      8) {
        toggle_class(
          span,
          "desc",
          /*$sort*/
          ((_b = ctx2[3]) == null ? void 0 : _b.direction) === "desc"
        );
      }
      if (dirty & /*align*/
      2) {
        set_style(
          div,
          "justify-content",
          /*align*/
          ctx2[1] === "left" ? "flex-start" : (
            /*align*/
            ctx2[1] === "right" ? "flex-end" : "center"
          )
        );
      }
      if (!current || dirty & /*$$props*/
      64 && th_class_value !== (th_class_value = null_to_empty(
        /*$$props*/
        ctx2[6].class ?? ""
      ) + " svelte-cur88x")) {
        attr_dev(th, "class", th_class_value);
      }
      if (!current || dirty & /*rowSpan*/
      4) {
        attr_dev(
          th,
          "rowspan",
          /*rowSpan*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$$props, orderBy*/
      65) {
        toggle_class(
          th,
          "sortable",
          /*orderBy*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$$props, $sort, orderBy*/
      73) {
        toggle_class(
          th,
          "active",
          /*$sort*/
          ((_c = ctx2[3]) == null ? void 0 : _c.orderBy) === /*orderBy*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $sort;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Th", slots, ["default"]);
  let { handler } = $$props;
  let { orderBy } = $$props;
  let { align = "left" } = $$props;
  let { rowSpan = 1 } = $$props;
  const sort = handler.getSort();
  validate_store(sort, "sort");
  component_subscribe($$self, sort, (value) => $$invalidate(3, $sort = value));
  const update = () => {
    handler.sort(orderBy);
    handler.invalidate();
  };
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<Th> was created without expected prop 'handler'");
    }
    if (orderBy === void 0 && !("orderBy" in $$props || $$self.$$.bound[$$self.$$.props["orderBy"]])) {
      console.warn("<Th> was created without expected prop 'orderBy'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(7, handler = $$new_props.handler);
    if ("orderBy" in $$new_props)
      $$invalidate(0, orderBy = $$new_props.orderBy);
    if ("align" in $$new_props)
      $$invalidate(1, align = $$new_props.align);
    if ("rowSpan" in $$new_props)
      $$invalidate(2, rowSpan = $$new_props.rowSpan);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    handler,
    orderBy,
    align,
    rowSpan,
    sort,
    update,
    $sort
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(7, handler = $$new_props.handler);
    if ("orderBy" in $$props)
      $$invalidate(0, orderBy = $$new_props.orderBy);
    if ("align" in $$props)
      $$invalidate(1, align = $$new_props.align);
    if ("rowSpan" in $$props)
      $$invalidate(2, rowSpan = $$new_props.rowSpan);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [orderBy, align, rowSpan, $sort, sort, update, $$props, handler, $$scope, slots];
}
var Th = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        handler: 7,
        orderBy: 0,
        align: 1,
        rowSpan: 2
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Th",
      options,
      id: create_fragment4.name
    });
  }
  get handler() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orderBy() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orderBy(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowSpan() {
    throw new Error("<Th>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowSpan(value) {
    throw new Error("<Th>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Th_default = Th;

// node_modules/@vincjo/datatables/dist/remote/ThFilter.svelte
var file5 = "node_modules\\@vincjo\\datatables\\dist\\remote\\ThFilter.svelte";
function add_css5(target) {
  append_styles(target, "svelte-7cnbqf", "th.svelte-7cnbqf{border-bottom:1px solid #e0e0e0}input.svelte-7cnbqf{width:100%;height:24px;border:none;text-align:left;padding:0 20px;background:inherit;outline:none;border-radius:0;font-size:14px;font-family:Arial, Helvetica, sans-serif}input.svelte-7cnbqf::-moz-placeholder{color:#bdbdbd;font-style:italic;font-size:13px}input.svelte-7cnbqf::placeholder{color:#bdbdbd;font-style:italic;font-size:13px}input.svelte-7cnbqf:focus{outline:none;border:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGhGaWx0ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRGVza3RvcFxcZGF0YWJhc2VfcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxAdmluY2pvXFxkYXRhdGFibGVzXFxkaXN0XFxyZW1vdGVcXFRoRmlsdGVyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment5(ctx) {
  let th;
  let input;
  let input_placeholder_value;
  let th_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      th = element("th");
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      input = claim_element(th_nodes, "INPUT", {
        type: true,
        placeholder: true,
        spellcheck: true,
        class: true
      });
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      attr_dev(input, "placeholder", input_placeholder_value = /*handler*/
      ctx[0].i18n.filter);
      attr_dev(input, "spellcheck", "false");
      attr_dev(input, "class", "svelte-7cnbqf");
      set_style(
        input,
        "text-align",
        /*align*/
        ctx[1]
      );
      add_location(input, file5, 15, 4, 322);
      attr_dev(th, "class", th_class_value = null_to_empty(
        /*$$props*/
        ctx[4].class ?? ""
      ) + " svelte-7cnbqf");
      add_location(th, file5, 14, 0, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, input);
      set_input_value(
        input,
        /*value*/
        ctx[2]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[6]
          ),
          listen_dev(
            input,
            "input",
            /*filter*/
            ctx[3],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*handler*/
      1 && input_placeholder_value !== (input_placeholder_value = /*handler*/
      ctx2[0].i18n.filter)) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (dirty & /*value*/
      4 && input.value !== /*value*/
      ctx2[2]) {
        set_input_value(
          input,
          /*value*/
          ctx2[2]
        );
      }
      if (dirty & /*align*/
      2) {
        set_style(
          input,
          "text-align",
          /*align*/
          ctx2[1]
        );
      }
      if (dirty & /*$$props*/
      16 && th_class_value !== (th_class_value = null_to_empty(
        /*$$props*/
        ctx2[4].class ?? ""
      ) + " svelte-7cnbqf")) {
        attr_dev(th, "class", th_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ThFilter", slots, []);
  let { handler } = $$props;
  let { filterBy } = $$props;
  let { align = "left" } = $$props;
  let value = "";
  let timeout;
  const filter = () => {
    handler.filter(value, filterBy);
    clearTimeout(timeout);
    timeout = setTimeout(
      () => {
        handler.invalidate();
      },
      400
    );
  };
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<ThFilter> was created without expected prop 'handler'");
    }
    if (filterBy === void 0 && !("filterBy" in $$props || $$self.$$.bound[$$self.$$.props["filterBy"]])) {
      console.warn("<ThFilter> was created without expected prop 'filterBy'");
    }
  });
  function input_input_handler() {
    value = this.value;
    $$invalidate(2, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("filterBy" in $$new_props)
      $$invalidate(5, filterBy = $$new_props.filterBy);
    if ("align" in $$new_props)
      $$invalidate(1, align = $$new_props.align);
  };
  $$self.$capture_state = () => ({
    handler,
    filterBy,
    align,
    value,
    timeout,
    filter
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("filterBy" in $$props)
      $$invalidate(5, filterBy = $$new_props.filterBy);
    if ("align" in $$props)
      $$invalidate(1, align = $$new_props.align);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("timeout" in $$props)
      timeout = $$new_props.timeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [handler, align, value, filter, $$props, filterBy, input_input_handler];
}
var ThFilter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { handler: 0, filterBy: 5, align: 1 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThFilter",
      options,
      id: create_fragment5.name
    });
  }
  get handler() {
    throw new Error("<ThFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<ThFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filterBy() {
    throw new Error("<ThFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filterBy(value) {
    throw new Error("<ThFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<ThFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<ThFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ThFilter_default = ThFilter;

// node_modules/@vincjo/datatables/dist/remote/RowCount.svelte
var file6 = "node_modules\\@vincjo\\datatables\\dist\\remote\\RowCount.svelte";
function add_css6(target) {
  append_styles(target, "svelte-9akqhk", "aside.svelte-9akqhk{color:#616161;line-height:32px;font-size:14px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUm93Q291bnQuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcVXNlclxcRGVza3RvcFxcZGF0YWJhc2VfcHJvamVjdFxcbm9kZV9tb2R1bGVzXFxAdmluY2pvXFxkYXRhdGFibGVzXFxkaXN0XFxyZW1vdGVcXFJvd0NvdW50LnN2ZWx0ZSJdfQ== */");
}
function create_else_block2(ctx) {
  let aside;
  let aside_class_value;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*small*/
      ctx2[1]
    )
      return create_if_block_13;
    if (
      /*$rowCount*/
      ctx2[2].total > 0
    )
      return create_if_block_32;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      aside = element("aside");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      if_block.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "class", aside_class_value = null_to_empty(
        /*$$props*/
        ctx[4].class ?? ""
      ) + " svelte-9akqhk");
      add_location(aside, file6, 8, 4, 163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if_block.m(aside, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(aside, null);
        }
      }
      if (dirty & /*$$props*/
      16 && aside_class_value !== (aside_class_value = null_to_empty(
        /*$$props*/
        ctx2[4].class ?? ""
      ) + " svelte-9akqhk")) {
        attr_dev(aside, "class", aside_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(8:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file6, 6, 4, 142);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(6:0) {#if $rowCount === undefined}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let t_value = (
    /*handler*/
    ctx[0].i18n.noRows + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.noRows + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(23:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let html_tag;
  let raw_value = (
    /*handler*/
    ctx[0].i18n.rowCount.replace("{start}", `<b>${/*$rowCount*/
    ctx[2].start}</b>`).replace("{end}", `<b>${/*$rowCount*/
    ctx[2].end}</b>`).replace("{total}", `<b>${/*$rowCount*/
    ctx[2].total}</b>`) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler, $rowCount*/
      5 && raw_value !== (raw_value = /*handler*/
      ctx2[0].i18n.rowCount.replace("{start}", `<b>${/*$rowCount*/
      ctx2[2].start}</b>`).replace("{end}", `<b>${/*$rowCount*/
      ctx2[2].end}</b>`).replace("{total}", `<b>${/*$rowCount*/
      ctx2[2].total}</b>`) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(18:38) ",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$rowCount*/
      ctx2[2].total > 0
    )
      return create_if_block_22;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_2(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(10:8) {#if small}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let t_value = (
    /*handler*/
    ctx[0].i18n.noRows + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && t_value !== (t_value = /*handler*/
      ctx2[0].i18n.noRows + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(15:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let b0;
  let t0_value = (
    /*$rowCount*/
    ctx[2].start + ""
  );
  let t0;
  let t1;
  let b1;
  let t2_value = (
    /*$rowCount*/
    ctx[2].end + ""
  );
  let t2;
  let t3;
  let b2;
  let t4_value = (
    /*$rowCount*/
    ctx[2].total + ""
  );
  let t4;
  const block = {
    c: function create() {
      b0 = element("b");
      t0 = text(t0_value);
      t1 = text("-\r\n                ");
      b1 = element("b");
      t2 = text(t2_value);
      t3 = text("/\r\n                ");
      b2 = element("b");
      t4 = text(t4_value);
      this.h();
    },
    l: function claim(nodes) {
      b0 = claim_element(nodes, "B", {});
      var b0_nodes = children(b0);
      t0 = claim_text(b0_nodes, t0_value);
      b0_nodes.forEach(detach_dev);
      t1 = claim_text(nodes, "-\r\n                ");
      b1 = claim_element(nodes, "B", {});
      var b1_nodes = children(b1);
      t2 = claim_text(b1_nodes, t2_value);
      b1_nodes.forEach(detach_dev);
      t3 = claim_text(nodes, "/\r\n                ");
      b2 = claim_element(nodes, "B", {});
      var b2_nodes = children(b2);
      t4 = claim_text(b2_nodes, t4_value);
      b2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b0, file6, 11, 16, 276);
      add_location(b1, file6, 12, 16, 319);
      add_location(b2, file6, 13, 16, 360);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, b0, anchor);
      append_hydration_dev(b0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, b1, anchor);
      append_hydration_dev(b1, t2);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, b2, anchor);
      append_hydration_dev(b2, t4);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$rowCount*/
      4 && t0_value !== (t0_value = /*$rowCount*/
      ctx2[2].start + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*$rowCount*/
      4 && t2_value !== (t2_value = /*$rowCount*/
      ctx2[2].end + ""))
        set_data_dev(t2, t2_value);
      if (dirty & /*$rowCount*/
      4 && t4_value !== (t4_value = /*$rowCount*/
      ctx2[2].total + ""))
        set_data_dev(t4, t4_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(b0);
        detach_dev(t1);
        detach_dev(b1);
        detach_dev(t3);
        detach_dev(b2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(11:12) {#if $rowCount.total > 0}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*$rowCount*/
      ctx2[2] === void 0
    )
      return create_if_block3;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $rowCount;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RowCount", slots, []);
  let { handler } = $$props;
  let { small = false } = $$props;
  const rowCount = handler.getRowCount();
  validate_store(rowCount, "rowCount");
  component_subscribe($$self, rowCount, (value) => $$invalidate(2, $rowCount = value));
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<RowCount> was created without expected prop 'handler'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props)
      $$invalidate(1, small = $$new_props.small);
  };
  $$self.$capture_state = () => ({ handler, small, rowCount, $rowCount });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$props)
      $$invalidate(1, small = $$new_props.small);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [handler, small, $rowCount, rowCount, $$props];
}
var RowCount = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { handler: 0, small: 1 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RowCount",
      options,
      id: create_fragment6.name
    });
  }
  get handler() {
    throw new Error("<RowCount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<RowCount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<RowCount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<RowCount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RowCount_default = RowCount;

// node_modules/@vincjo/datatables/dist/remote/SelectedCount.svelte
var file7 = "node_modules\\@vincjo\\datatables\\dist\\remote\\SelectedCount.svelte";
function add_css7(target) {
  append_styles(target, "svelte-sa2ro0", "aside.svelte-sa2ro0{color:#616161;line-height:32px;font-size:14px}button.svelte-sa2ro0{background:#fafafa;padding:2px 4px;border-radius:2px;cursor:pointer;border:1px solid #e0e0e0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0ZWRDb3VudC5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEZXNrdG9wXFxkYXRhYmFzZV9wcm9qZWN0XFxub2RlX21vZHVsZXNcXEB2aW5jam9cXGRhdGF0YWJsZXNcXGRpc3RcXHJlbW90ZVxcU2VsZWN0ZWRDb3VudC5zdmVsdGUiXX0= */");
}
function create_if_block_14(ctx) {
  let t0;
  let b;
  let t1_value = (
    /*$selectedCount*/
    ctx[1].total + ""
  );
  let t1;
  const block = {
    c: function create() {
      t0 = text("of ");
      b = element("b");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, "of ");
      b = claim_element(nodes, "B", {});
      var b_nodes = children(b);
      t1 = claim_text(b_nodes, t1_value);
      b_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file7, 9, 11, 211);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, b, anchor);
      append_hydration_dev(b, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$selectedCount*/
      2 && t1_value !== (t1_value = /*$selectedCount*/
      ctx2[1].total + ""))
        set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(b);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(9:4) {#if $selectedCount.total}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let button;
  let textContent = "❌ Clear";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      button.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button) !== "svelte-1p0u46p")
        button.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "svelte-sa2ro0");
      add_location(button, file7, 13, 8, 319);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(13:4) {#if $selectedCount.count > 0}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let aside;
  let b;
  let t0_value = (
    /*$selectedCount*/
    ctx[1].count + ""
  );
  let t0;
  let t1;
  let t2;
  let aside_class_value;
  let if_block0 = (
    /*$selectedCount*/
    ctx[1].total && create_if_block_14(ctx)
  );
  let if_block1 = (
    /*$selectedCount*/
    ctx[1].count > 0 && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      aside = element("aside");
      b = element("b");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = text("\r\n    row(s) selected.\r\n    ");
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { class: true });
      var aside_nodes = children(aside);
      b = claim_element(aside_nodes, "B", {});
      var b_nodes = children(b);
      t0 = claim_text(b_nodes, t0_value);
      b_nodes.forEach(detach_dev);
      t1 = claim_space(aside_nodes);
      if (if_block0)
        if_block0.l(aside_nodes);
      t2 = claim_text(aside_nodes, "\r\n    row(s) selected.\r\n    ");
      if (if_block1)
        if_block1.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file7, 7, 4, 136);
      attr_dev(aside, "class", aside_class_value = null_to_empty(
        /*$$props*/
        ctx[3].class ?? ""
      ) + " svelte-sa2ro0");
      add_location(aside, file7, 5, 0, 93);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      append_hydration_dev(aside, b);
      append_hydration_dev(b, t0);
      append_hydration_dev(aside, t1);
      if (if_block0)
        if_block0.m(aside, null);
      append_hydration_dev(aside, t2);
      if (if_block1)
        if_block1.m(aside, null);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$selectedCount*/
      2 && t0_value !== (t0_value = /*$selectedCount*/
      ctx2[1].count + ""))
        set_data_dev(t0, t0_value);
      if (
        /*$selectedCount*/
        ctx2[1].total
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(aside, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$selectedCount*/
        ctx2[1].count > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          if_block1.m(aside, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*$$props*/
      8 && aside_class_value !== (aside_class_value = null_to_empty(
        /*$$props*/
        ctx2[3].class ?? ""
      ) + " svelte-sa2ro0")) {
        attr_dev(aside, "class", aside_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $selectedCount;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SelectedCount", slots, []);
  let { handler } = $$props;
  const selectedCount = handler.getSelectedCount();
  validate_store(selectedCount, "selectedCount");
  component_subscribe($$self, selectedCount, (value) => $$invalidate(1, $selectedCount = value));
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<SelectedCount> was created without expected prop 'handler'");
    }
  });
  const click_handler = () => handler.clearSelection();
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
  };
  $$self.$capture_state = () => ({ handler, selectedCount, $selectedCount });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(3, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [handler, $selectedCount, selectedCount, $$props, click_handler];
}
var SelectedCount = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { handler: 0 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SelectedCount",
      options,
      id: create_fragment7.name
    });
  }
  get handler() {
    throw new Error("<SelectedCount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<SelectedCount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SelectedCount_default = SelectedCount;

// node_modules/@vincjo/datatables/dist/remote/Pagination.svelte
var file8 = "node_modules\\@vincjo\\datatables\\dist\\remote\\Pagination.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1u2assi", "section.svelte-1u2assi{display:flex}button.svelte-1u2assi{background:inherit;height:32px;width:32px;color:#616161;cursor:pointer;font-size:13px;margin:0;padding:0;transition:all, 0.2s;line-height:32px;border:1px solid #e0e0e0;border-right:none;border-radius:0;outline:none}button.svelte-1u2assi:first-child{border-radius:4px 0 0 4px}button.svelte-1u2assi:last-child{border-right:1px solid #e0e0e0;border-radius:0 4px 4px 0}button.svelte-1u2assi:first-child:not(.small),button.svelte-1u2assi:last-child:not(.small){min-width:72px}button.svelte-1u2assi:not(.active):hover{background:#eee}button.disabled.svelte-1u2assi:hover{background:inherit;cursor:default}button.page.svelte-1u2assi{width:72px;background:#fafafa}button.page.svelte-1u2assi:hover{background:#fafafa;cursor:default}button.ellipse.svelte-1u2assi:hover{background:inherit;cursor:default}button.active.svelte-1u2assi{background:#eee;font-weight:bold;cursor:default}button.disabled.svelte-1u2assi{color:#bdbdbd}button.disabled.svelte-1u2assi:hover{background:inherit;cursor:default}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGFnaW5hdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxVc2VyXFxEZXNrdG9wXFxkYXRhYmFzZV9wcm9qZWN0XFxub2RlX21vZHVsZXNcXEB2aW5jam9cXGRhdGF0YWJsZXNcXGRpc3RcXHJlbW90ZVxcUGFnaW5hdGlvbi5zdmVsdGUiXX0= */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_else_block3(ctx) {
  let button0;
  let html_tag;
  let raw0_value = (
    /*handler*/
    ctx[0].i18n.previous + ""
  );
  let t0;
  let t1;
  let button1;
  let html_tag_1;
  let raw1_value = (
    /*handler*/
    ctx[0].i18n.next + ""
  );
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*$pages*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      button0 = element("button");
      html_tag = new HtmlTagHydration(false);
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      button1 = element("button");
      html_tag_1 = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button0 = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      html_tag = claim_html_tag(button0_nodes, false);
      button0_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      html_tag_1 = claim_html_tag(button1_nodes, false);
      button1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", "svelte-1u2assi");
      toggle_class(
        button0,
        "disabled",
        /*$pageNumber*/
        ctx[3] === 1
      );
      add_location(button0, file8, 58, 12, 1763);
      html_tag_1.a = null;
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", "svelte-1u2assi");
      toggle_class(
        button1,
        "disabled",
        /*$pageNumber*/
        ctx[3] === /*$pageCount*/
        ctx[4]
      );
      add_location(button1, file8, 75, 12, 2366);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button0, anchor);
      html_tag.m(raw0_value, button0);
      insert_hydration_dev(target, t0, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button1, anchor);
      html_tag_1.m(raw1_value, button1);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler_6*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_8*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*handler*/
      1 && raw0_value !== (raw0_value = /*handler*/
      ctx2[0].i18n.previous + ""))
        html_tag.p(raw0_value);
      if (dirty & /*$pageNumber*/
      8) {
        toggle_class(
          button0,
          "disabled",
          /*$pageNumber*/
          ctx2[3] === 1
        );
      }
      if (dirty & /*$pageNumber, $pages, setPage*/
      268) {
        each_value = ensure_array_like_dev(
          /*$pages*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(t1.parentNode, t1);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*handler*/
      1 && raw1_value !== (raw1_value = /*handler*/
      ctx2[0].i18n.next + ""))
        html_tag_1.p(raw1_value);
      if (dirty & /*$pageNumber, $pageCount*/
      24) {
        toggle_class(
          button1,
          "disabled",
          /*$pageNumber*/
          ctx2[3] === /*$pageCount*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button0);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(button1);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(58:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let button0;
  let textContent = "❬❬";
  let t1;
  let button1;
  let textContent_1 = "❮";
  let t3;
  let button2;
  let textContent_2 = "❯";
  let t5;
  let button3;
  let textContent_3 = "❭❭";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button0 = element("button");
      button0.textContent = textContent;
      t1 = space();
      button1 = element("button");
      button1.textContent = textContent_1;
      t3 = space();
      button2 = element("button");
      button2.textContent = textContent_2;
      t5 = space();
      button3 = element("button");
      button3.textContent = textContent_3;
      this.h();
    },
    l: function claim(nodes) {
      button0 = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-hfxwd1")
        button0.textContent = textContent;
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button1) !== "svelte-1jkuczb")
        button1.textContent = textContent_1;
      t3 = claim_space(nodes);
      button2 = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button2) !== "svelte-o9kt4c")
        button2.textContent = textContent_2;
      t5 = claim_space(nodes);
      button3 = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button3) !== "svelte-x4b4wi")
        button3.textContent = textContent_3;
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", "small svelte-1u2assi");
      toggle_class(
        button0,
        "disabled",
        /*$pageNumber*/
        ctx[3] === 1
      );
      add_location(button0, file8, 29, 12, 837);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", "svelte-1u2assi");
      toggle_class(
        button1,
        "disabled",
        /*$pageNumber*/
        ctx[3] === 1
      );
      add_location(button1, file8, 37, 12, 1089);
      attr_dev(button2, "class", "svelte-1u2assi");
      toggle_class(
        button2,
        "disabled",
        /*$pageNumber*/
        ctx[3] === /*$pageCount*/
        ctx[4]
      );
      add_location(button2, file8, 44, 12, 1311);
      attr_dev(button3, "class", "small svelte-1u2assi");
      toggle_class(
        button3,
        "disabled",
        /*$pageNumber*/
        ctx[3] === /*$pageCount*/
        ctx[4]
      );
      add_location(button3, file8, 50, 12, 1507);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button1, anchor);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, button2, anchor);
      insert_hydration_dev(target, t5, anchor);
      insert_hydration_dev(target, button3, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler_2*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_3*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            /*click_handler_4*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button3,
            "click",
            /*click_handler_5*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$pageNumber*/
      8) {
        toggle_class(
          button0,
          "disabled",
          /*$pageNumber*/
          ctx2[3] === 1
        );
      }
      if (dirty & /*$pageNumber*/
      8) {
        toggle_class(
          button1,
          "disabled",
          /*$pageNumber*/
          ctx2[3] === 1
        );
      }
      if (dirty & /*$pageNumber, $pageCount*/
      24) {
        toggle_class(
          button2,
          "disabled",
          /*$pageNumber*/
          ctx2[3] === /*$pageCount*/
          ctx2[4]
        );
      }
      if (dirty & /*$pageNumber, $pageCount*/
      24) {
        toggle_class(
          button3,
          "disabled",
          /*$pageNumber*/
          ctx2[3] === /*$pageCount*/
          ctx2[4]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button0);
        detach_dev(t1);
        detach_dev(button1);
        detach_dev(t3);
        detach_dev(button2);
        detach_dev(t5);
        detach_dev(button3);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(29:8) {#if small}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let button0;
  let textContent = "❮";
  let t1;
  let button1;
  let t2;
  let b;
  let t3;
  let t4;
  let button2;
  let textContent_1 = "❯";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button0 = element("button");
      button0.textContent = textContent;
      t1 = space();
      button1 = element("button");
      t2 = text("page ");
      b = element("b");
      t3 = text(
        /*$pageNumber*/
        ctx[3]
      );
      t4 = space();
      button2 = element("button");
      button2.textContent = textContent_1;
      this.h();
    },
    l: function claim(nodes) {
      button0 = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-19hopyr")
        button0.textContent = textContent;
      t1 = claim_space(nodes);
      button1 = claim_element(nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t2 = claim_text(button1_nodes, "page ");
      b = claim_element(button1_nodes, "B", {});
      var b_nodes = children(b);
      t3 = claim_text(
        b_nodes,
        /*$pageNumber*/
        ctx[3]
      );
      b_nodes.forEach(detach_dev);
      button1_nodes.forEach(detach_dev);
      t4 = claim_space(nodes);
      button2 = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button2) !== "svelte-bo7tc1")
        button2.textContent = textContent_1;
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", "small svelte-1u2assi");
      toggle_class(
        button0,
        "disabled",
        /*$pageNumber*/
        ctx[3] === 1
      );
      add_location(button0, file8, 13, 8, 370);
      add_location(b, file8, 20, 34, 604);
      attr_dev(button1, "class", "page svelte-1u2assi");
      add_location(button1, file8, 20, 8, 578);
      attr_dev(button2, "type", "button");
      attr_dev(button2, "class", "small svelte-1u2assi");
      add_location(button2, file8, 21, 8, 643);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, button1, anchor);
      append_hydration_dev(button1, t2);
      append_hydration_dev(button1, b);
      append_hydration_dev(b, t3);
      insert_hydration_dev(target, t4, anchor);
      insert_hydration_dev(target, button2, anchor);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            /*click_handler_1*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$pageNumber*/
      8) {
        toggle_class(
          button0,
          "disabled",
          /*$pageNumber*/
          ctx2[3] === 1
        );
      }
      if (dirty & /*$pageNumber*/
      8)
        set_data_dev(
          t3,
          /*$pageNumber*/
          ctx2[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button0);
        detach_dev(t1);
        detach_dev(button1);
        detach_dev(t4);
        detach_dev(button2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(13:4) {#if $pages === undefined}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let button;
  let t_value = (
    /*page*/
    (ctx[19] ?? "...") + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_7() {
    return (
      /*click_handler_7*/
      ctx[17](
        /*page*/
        ctx[19]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "svelte-1u2assi");
      toggle_class(
        button,
        "active",
        /*$pageNumber*/
        ctx[3] === /*page*/
        ctx[19]
      );
      toggle_class(
        button,
        "ellipse",
        /*page*/
        ctx[19] === null
      );
      add_location(button, file8, 66, 16, 2046);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_7, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$pages*/
      4 && t_value !== (t_value = /*page*/
      (ctx[19] ?? "...") + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$pageNumber, $pages*/
      12) {
        toggle_class(
          button,
          "active",
          /*$pageNumber*/
          ctx[3] === /*page*/
          ctx[19]
        );
      }
      if (dirty & /*$pages*/
      4) {
        toggle_class(
          button,
          "ellipse",
          /*page*/
          ctx[19] === null
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(66:12) {#each $pages as page}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let section;
  let section_class_value;
  function select_block_type(ctx2, dirty) {
    if (
      /*$pages*/
      ctx2[2] === void 0
    )
      return create_if_block5;
    if (
      /*small*/
      ctx2[1]
    )
      return create_if_block_15;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      section = element("section");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if_block.l(section_nodes);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(section, "class", section_class_value = null_to_empty(
        /*$$props*/
        ctx[9].class ?? ""
      ) + " svelte-1u2assi");
      add_location(section, file8, 11, 0, 291);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      if_block.m(section, null);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(section, null);
        }
      }
      if (dirty & /*$$props*/
      512 && section_class_value !== (section_class_value = null_to_empty(
        /*$$props*/
        ctx2[9].class ?? ""
      ) + " svelte-1u2assi")) {
        attr_dev(section, "class", section_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(section);
      }
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let $pages;
  let $pageNumber;
  let $pageCount;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, []);
  let { handler } = $$props;
  let { small = false } = $$props;
  const pageNumber = handler.getPageNumber();
  validate_store(pageNumber, "pageNumber");
  component_subscribe($$self, pageNumber, (value) => $$invalidate(3, $pageNumber = value));
  const pageCount = handler.getPageCount();
  validate_store(pageCount, "pageCount");
  component_subscribe($$self, pageCount, (value) => $$invalidate(4, $pageCount = value));
  const pages = handler.getPages({ ellipsis: true });
  validate_store(pages, "pages");
  component_subscribe($$self, pages, (value) => $$invalidate(2, $pages = value));
  const setPage = (value) => {
    handler.setPage(value);
    handler.invalidate();
  };
  $$self.$$.on_mount.push(function() {
    if (handler === void 0 && !("handler" in $$props || $$self.$$.bound[$$self.$$.props["handler"]])) {
      console.warn("<Pagination> was created without expected prop 'handler'");
    }
  });
  const click_handler = () => setPage("previous");
  const click_handler_1 = () => setPage("next");
  const click_handler_2 = () => setPage(1);
  const click_handler_3 = () => setPage("previous");
  const click_handler_4 = () => setPage("next");
  const click_handler_5 = () => setPage($pageCount);
  const click_handler_6 = () => setPage("previous");
  const click_handler_7 = (page) => setPage(page);
  const click_handler_8 = () => setPage("next");
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("handler" in $$new_props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$new_props)
      $$invalidate(1, small = $$new_props.small);
  };
  $$self.$capture_state = () => ({
    handler,
    small,
    pageNumber,
    pageCount,
    pages,
    setPage,
    $pages,
    $pageNumber,
    $pageCount
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("handler" in $$props)
      $$invalidate(0, handler = $$new_props.handler);
    if ("small" in $$props)
      $$invalidate(1, small = $$new_props.small);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [
    handler,
    small,
    $pages,
    $pageNumber,
    $pageCount,
    pageNumber,
    pageCount,
    pages,
    setPage,
    $$props,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    click_handler_8
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { handler: 0, small: 1 }, add_css8);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment8.name
    });
  }
  get handler() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handler(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get small() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set small(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;
export {
  DataHandler,
  Datatable_default as Datatable,
  Pagination_default as Pagination,
  RowCount_default as RowCount,
  RowsPerPage_default as RowsPerPage,
  Search_default as Search,
  SelectedCount_default as SelectedCount,
  Th_default as Th,
  ThFilter_default as ThFilter
};
//# sourceMappingURL=@vincjo_datatables_remote.js.map
